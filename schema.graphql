"""
Requires that exactly one field must be supplied and that field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

"""Autogenerated input type of AcceptChannelTransferMutation"""
input AcceptChannelTransferMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: String!
}

"""Autogenerated return type of AcceptChannelTransferMutation."""
type AcceptChannelTransferMutationPayload {
  channel_transfer_request: ChannelTransferRequest!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of AcceptGroupInviteMutation"""
input AcceptGroupInviteMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  code: String!
}

"""Autogenerated return type of AcceptGroupInviteMutation."""
type AcceptGroupInviteMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group: Group!
}

"""Autogenerated input type of AcceptInvitationMutation"""
input AcceptInvitationMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  invitation_token: String!
  first_name: String!
  last_name: String!
  email: String!
  password: String!
  password_confirmation: String!
  receive_newsletter: Boolean
  receive_tips_emails: Boolean
  receive_editorial_emails: Boolean
  validation_token: String
}

"""Autogenerated return type of AcceptInvitationMutation."""
type AcceptInvitationMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me
}

"""Autogenerated input type of AddChannelMembersMutation"""
input AddChannelMembersMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  members: [ChannelMemberInput!]!
}

"""Autogenerated return type of AddChannelMembersMutation."""
type AddChannelMembersMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of AddCollaboratorMutation"""
input AddCollaboratorMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  channel_id: ID!
  user_ids: [ID]!
}

"""Autogenerated return type of AddCollaboratorMutation."""
type AddCollaboratorMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of AddCreditCardMutation"""
input AddCreditCardMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: String!
  default_source: Boolean
}

"""Autogenerated return type of AddCreditCardMutation."""
type AddCreditCardMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customer: Customer!
}

"""Autogenerated input type of AddGroupUsersMutation"""
input AddGroupUsersMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  user_ids: [ID]!
}

"""Autogenerated return type of AddGroupUsersMutation."""
type AddGroupUsersMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group: Group!
}

"""Autogenerated input type of AddPaymentMethodMutation"""
input AddPaymentMethodMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: String!
  default_source: Boolean
}

"""Autogenerated return type of AddPaymentMethodMutation."""
type AddPaymentMethodMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customer: Customer!
}

type Address {
  city: String
  country: String
  line1: String
  line2: String
  postal_code: String
  state: String
}

"""Available filters for the given advanced Search"""
type AdvancedFilterResult {
  fields: [FieldsEnum!]
  order: [SortOrderEnum!]
  what: [WhatEnum!]
  where: [WhereEnum!]
}

"""Result for the advanced Search"""
type AdvancedResult {
  filters: AdvancedFilterResult
  results: [SsearchResult]
  total: Int!
}

"""Autogenerated input type of ApplyCouponToSubscriptionMutation"""
input ApplyCouponToSubscriptionMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  coupon_code: String!
}

"""Autogenerated return type of ApplyCouponToSubscriptionMutation."""
type ApplyCouponToSubscriptionMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""An attachment block"""
type Attachment implements Block & ConnectableInterface & Model {
  can: BlockCan
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]
  channels_with_same_source(per: Int = 25, page: Int = 1): [Channel!]
  comments(direction: SortDirection = ASC): [Comment!] @deprecated(reason: "Channels do not have comments. Call this on Block.")

  """Returns the outer channel if we are inside of one"""
  connection: Connection
  connections: [Connection]
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String!
  current_user_channels: [Channel!]
  description(format: Format, no_links: Boolean = false): String
  file_content_type: String
  file_extension: String
  file_size(precision: Int = 3): String
  file_url: String
  href(absolute: Boolean = false): String
  id: Int!
  image_updated_at(relative: Boolean, format: String): String
  image_url(size: ImageVersion = DISPLAY): String
  is_muted: Boolean!
  is_nsfw: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  private_accessible_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  public_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  resized_image_url(width: Int, height: Int, quality: Int = 75, blur: Int, sharpen: Int, flatten: Boolean, fallback_format: ResizedImageFallbackFormat, downloadable: Boolean): String
  source: ConnectableSource
  state: String!
  title(truncate: Int): String!
  to_s(truncate: Int): String!
  updated_at(relative: Boolean, format: String): String!
  user: User
  visibility: String
}

"""Providers for external authentication"""
enum AuthenticatedServiceProvider {
  TWITTER
}

"""An authorized external service provider"""
type Authentication implements Model {
  contacts(per: Int = 50, page: Int = 1): [User!]
  created_at(relative: Boolean, format: String): String!
  id: Int!
  provider: String
  uid: String
  updated_at(relative: Boolean, format: String): String!
}

"""Avatar sizes"""
enum AvatarVersion {
  SMALL
  MEDIUM
  LARGE
  UNCROPPED
}

enum BannerEnum {
  STRONGLY_PROPOSE_PREMIUM
  PROPOSE_PREMIUM
  CREATE_CHANNEL
  CREATE_CONNECTIONS
  FOLLOW_ANYTHING
  CONFIRM
  BOOKMARKLET
  INVITE
  MONTHLY_PREMIUM_REMINDER
  PREMIUM_PLUS
  PREVIOUSLY_PREMIUM
}

"""Possible connectables for a new connection"""
enum BaseConnectableTypeEnum {
  BLOCK
  CHANNEL
}

"""Fields common to all Block types"""
interface Block {
  can: BlockCan
  channels_with_same_source(per: Int = 25, page: Int = 1): [Channel!]
  comments(direction: SortDirection = ASC): [Comment!]
  counts: BlockCounts
  is_nsfw: Boolean
  state: String
}

"""The actions that the CurrentUser can perform on the Block"""
type BlockCan {
  comment: Boolean!
  connect: Boolean!
  edit_thumbnail: Boolean!
  manage: Boolean!
  mute: Boolean!
  potentially_edit_thumbnail: Boolean!
  read: Boolean!
  remove_connection(channel_id: ID!): Boolean!
}

type BlockCounts {
  channels: Int
  channels_by_current_user: Int
  channels_with_same_source: Int
  comments: Int
  private_accessible_channels: Int
  public_channels: Int
}

"""Block types"""
enum BlockFilterEnum {
  ALL
  IMAGE
  EMBED
  TEXT
  ATTACHMENT
  LINK
}

"""Autogenerated input type of CancelChannelTransferMutation"""
input CancelChannelTransferMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of CancelChannelTransferMutation."""
type CancelChannelTransferMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of CancelPremiumSubscriptionMutation"""
input CancelPremiumSubscriptionMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of CancelPremiumSubscriptionMutation."""
type CancelPremiumSubscriptionMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""Autogenerated input type of CancelPremiumSubscriptionsMutation"""
input CancelPremiumSubscriptionsMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user_ids: [ID]!
}

"""Autogenerated return type of CancelPremiumSubscriptionsMutation."""
type CancelPremiumSubscriptionsMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
  users: [User!]!
}

"""A distinct URL with extra info extracted"""
type CanonicalLink implements Model {
  authors: String
  content: String
  created_at(relative: Boolean, format: String): String!
  description: String
  id: Int!
  provider_name: String
  provider_url: String
  published_at(relative: Boolean, format: String): String
  safe: Boolean!
  state: String
  title: String
  updated_at(relative: Boolean, format: String): String!
  url: String
}

"""A single channel"""
type Channel implements ConnectableInterface & Followable & Model & Mutable {
  added_to_at(relative: Boolean, format: String): String
  blocks(per: Int = 25, page: Int = 1, sort_by: Sorts = POSITION, direction: SortDirection = ASC, type: ConnectableTypeEnum = null, user_id: ID = null): [Connectable!] @deprecated(reason: "Use `blokks` until this can be replaced with it")
  blokks(per: Int = 25, page: Int = 1, sort_by: Sorts = POSITION, direction: SortDirection = ASC, type: ConnectableTypeEnum = null, user_id: ID = null): [Konnectable!]!
  can: ChannelCan!
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]
  collaborators: [User!] @deprecated(reason: "This only returns Users. Use `members` field instead")
  comments(direction: SortDirection = ASC): [Comment!] @deprecated(reason: "Channels do not have comments. Call this on Block.")

  """
  Returns a gzipped and base64 encoded JSON string of the unfiltered channel skeleton
  """
  compressed_skeleton: String!
  connected_to_channels(per: Int = null, page: Int = null): [Channel!]!

  """Returns the outer channel if we are inside of one"""
  connection: Connection
  connections: [Connection]
  connectors(q: String = null, per: Int = 25, page: Int = 1): [User!]!
  content_flag: String
  contents(connectables: [ConnectableInput]): [Konnectable!]
  counts: ChannelCounts!
  created_at(relative: Boolean, format: String): String!
  current_user_channels: [Channel!]
  description(format: Format, no_links: Boolean = false): String
  filter(q: String = null, per: Int = 25, page: Int = 1): [Konnectable!]!
  followers(per: Int = 25, page: Int = 1): [User!]
  href(absolute: Boolean = false): String!
  id: Int!
  image_url(size: ImageVersion = DISPLAY): String
  is_collaboration: Boolean!
  is_followed: Boolean!
  is_muted: Boolean!
  is_nsfw: Boolean!
  is_open: Boolean! @deprecated(reason: "Use `visibility`")
  is_pending_transfer: Boolean!
  is_published: Boolean! @deprecated(reason: "Use `visibility`")
  is_restricted: Boolean!
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  members: [Member!]!
  memberships: [ChannelMembership!]!
  owner: ChannelOwner!
  private_accessible_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  public_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  share: ChannelShare
  share_id: String
  skeleton(type: [BaseConnectableTypeEnum!] = [BLOCK, CHANNEL]): [SkeletalConnectable!]!
  slug: String!
  source: ConnectableSource
  state: String!
  title(truncate: Int): String!
  to_s(truncate: Int): String!
  transfer_request: ChannelTransferRequest
  type: String!
  types: [ConnectableTypeEnum!]!
  updated_at(relative: Boolean, format: String): String!
  user: User
  visibility: String!
}

"""The actions that the CurrentUser can perform on the Channel"""
type ChannelCan {
  add_to: Boolean!
  add_to_as_premium: Boolean!
  connect: Boolean!
  destroy: Boolean!
  export: Boolean!
  follow: Boolean!
  manage: Boolean!
  manage_collaborators: Boolean!
  mute: Boolean!
  read: Boolean!
  remove_connection(channel_id: ID!): Boolean!
  share: Boolean!
  transfer: Boolean!
  update: Boolean!
}

type ChannelCounts {
  blocks: Int!
  channels: Int!
  collaborators: Int!
  connected_to_channels: Int!
  contents(type: ConnectableTypeEnum = null, user_id: ID = null): Int!
  followers: Int!
}

input ChannelMemberInput {
  id: ID!
  type: MemberTypes = USER
}

"""
A membership defining the relationship between Channels and Members (Users or Groups)
"""
type ChannelMembership implements Model {
  can: ChannelMembershipCan
  created_at(relative: Boolean, format: String): String!
  id: Int!
  member: Member
  updated_at(relative: Boolean, format: String): String!
}

"""The actions that the CurrentUser can perform on the ChannelMembership"""
type ChannelMembershipCan {
  manage: Boolean!
}

union ChannelOwner = Group | User

enum ChannelOwnerTypeEnum {
  USER
  GROUP
}

"""Properties needed to share channels externally"""
type ChannelShare {
  facebook_url: String
  twitter_url: String
  url: String
}

"""A request to transfer the ownership of a channel to a new user"""
type ChannelTransferRequest implements Model {
  channel: Channel!
  created_at(relative: Boolean, format: String): String!
  id: Int!
  is_recipient_member: Boolean!
  is_user_to_member: Boolean @deprecated(reason: "User => Owner: use `is_recipient_member` field")
  recipient: ChannelOwner!
  sender: ChannelOwner!
  updated_at(relative: Boolean, format: String): String!
  user_from: User @deprecated(reason: "User => Owner: use `sender` field")
  user_to: User @deprecated(reason: "User => Owner: use recipient field")
}

"""Privacy states for a channel"""
enum ChannelVisibility {
  PUBLIC
  CLOSED
  PRIVATE
}

"""Ways to sort channels"""
enum ChannelsSort {
  ADDED_TO_AT
  UPDATED_AT
  CREATED_AT
  TITLE
}

"""Autogenerated input type of ClearNotificationsMutation"""
input ClearNotificationsMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  confirm: Boolean!
}

"""Autogenerated return type of ClearNotificationsMutation."""
type ClearNotificationsMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""A single comment"""
type Comment implements Model {
  body(truncate: Int, format: Format, no_links: Boolean = false): String
  can: CommentCan
  commentable: Commentable!
  created_at(relative: Boolean, format: String): String!
  href(absolute: Boolean = false): String
  id: Int!
  updated_at(relative: Boolean, format: String): String!
  user: User
}

type CommentCan {
  destroy: Boolean!
  manage: Boolean!
}

"""Union of objects that can be commented on"""
union Commentable = Attachment | Embed | Image | Link | PendingBlock | Text

"""Autogenerated input type of ConfirmAccountMutation"""
input ConfirmAccountMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: String!
}

"""Autogenerated return type of ConfirmAccountMutation."""
type ConfirmAccountMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  status: ConfirmedStatus!
  user: Me!
}

"""State of the logged in account"""
enum ConfirmedStatus {
  CONFIRMED
  ALREADY_CONFIRMED
  ERROR
}

"""A block or a channel"""
type Connectable implements ConnectableInterface & Model & Mutable {
  can: ConnectableCan @deprecated(reason: "Use specific type cans")
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]
  comments(direction: SortDirection = ASC): [Comment!] @deprecated(reason: "Channels do not have comments. Call this on Block.")

  """Returns the outer channel if we are inside of one"""
  connection: Connection
  connections: [Connection]
  created_at(relative: Boolean, format: String): String!
  current_user_channels: [Channel!]
  description(format: Format, no_links: Boolean = false): String
  href(absolute: Boolean = false): String
  id: Int!
  is_muted: Boolean!
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  private_accessible_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  public_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  source: ConnectableSource
  state: String!
  title(truncate: Int): String!
  to_s(truncate: Int): String!
  updated_at(relative: Boolean, format: String): String!
  user: User
  visibility: String
}

"""The actions that the CurrentUser can perform on the Connectable"""
type ConnectableCan {
  manage: Boolean!
  read: Boolean!
}

input ConnectableInput {
  id: ID!
  type: BaseConnectableTypeEnum!
}

"""Fields common to models that can be connected"""
interface ConnectableInterface {
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]
  comments(direction: SortDirection = ASC): [Comment!] @deprecated(reason: "Channels do not have comments. Call this on Block.")

  """Returns the outer channel if we are inside of one"""
  connection: Connection
  connections: [Connection]
  current_user_channels: [Channel!]
  description(format: Format, no_links: Boolean = false): String
  href(absolute: Boolean = false): String
  is_muted: Boolean!
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  private_accessible_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  public_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  source: ConnectableSource
  state: String!
  title(truncate: Int): String!
  to_s(truncate: Int): String!
  user: User
  visibility: String
}

"""Connectable attributes specific to its class"""
union ConnectableKind = Attachment | Channel | Embed | Image | Link | PendingBlock | Text

type ConnectableSource {
  provider_name: String
  provider_url: String
  title: String
  url: String
}

"""Connectable types"""
enum ConnectableTypeEnum {
  IMAGE
  EMBED
  TEXT
  CHANNEL
  ATTACHMENT
  LINK
  BLOCK
}

"""A connection"""
type Connection implements Model {
  can: ConnectionCan
  channel: Channel!
  connectable: Connectable!
  created_at(relative: Boolean, format: String): String!
  id: Int!
  position: Int!
  selected: Boolean!
  updated_at(relative: Boolean, format: String): String!
  user: User
}

"""The actions that the CurrentUser can perform on the Connection"""
type ConnectionCan {
  create: Boolean!
  destroy: Boolean!
  manage: Boolean!
}

"""Available content flag states for channels"""
enum ContentFlag {
  NSFW
  SAFE
}

type Coupon {
  amount_off: Int
  code: String
  created_at(relative: Boolean, format: String): String
  currency: String
  description: String
  duration: String
  duration_in_months: String
  id: String
  is_valid: Boolean
  percent_off: Int
  redeem_by(relative: Boolean, format: String): String
}

"""Autogenerated input type of CreateAuthenticatedServiceMutation"""
input CreateAuthenticatedServiceMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  provider: AuthenticatedServiceProvider = TWITTER
  uid: String!
  avatar_url: String
  token: String!
  secret: String!
}

"""Autogenerated return type of CreateAuthenticatedServiceMutation."""
type CreateAuthenticatedServiceMutationPayload {
  authenticated_service: Authentication!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of CreateBlockMutation"""
input CreateBlockMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  channel_ids: [ID]!
  source_url: String
  content: String
  value: String
  title: String
  description: String
  original_source_url: String
  original_source_title: String
  alt_text: String
}

"""Autogenerated return type of CreateBlockMutation."""
type CreateBlockMutationPayload {
  block: Connectable!
  blokk: Konnectable!
  channels: [Channel!]!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of CreateChannel"""
input CreateChannelInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  title: String!
  visibility: ChannelVisibility = CLOSED
  description: String
  group_id: ID
}

"""Autogenerated return type of CreateChannel."""
type CreateChannelPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of CreateCommentMutation"""
input CreateCommentMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  block_id: ID!
  body: String!
}

"""Autogenerated return type of CreateCommentMutation."""
type CreateCommentMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  comment: Comment!
}

"""Autogenerated input type of CreateConnectionMutation"""
input CreateConnectionMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  connectable_id: ID!
  connectable_type: BaseConnectableTypeEnum!
  channel_ids: [ID]
}

"""Autogenerated return type of CreateConnectionMutation."""
type CreateConnectionMutationPayload {
  channels: [Channel!]!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  connectable: Connectable!
  connections(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
  ): [Connection!]!
  konnectable: Konnectable!
}

"""Autogenerated input type of CreateCustomerPortalSessionMutation"""
input CreateCustomerPortalSessionMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of CreateCustomerPortalSessionMutation."""
type CreateCustomerPortalSessionMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  url: String!
}

"""Autogenerated input type of CreateGroupInviteMutation"""
input CreateGroupInviteMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group_id: ID
}

"""Autogenerated return type of CreateGroupInviteMutation."""
type CreateGroupInviteMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group: Group!
}

"""Autogenerated input type of CreateGroupMutation"""
input CreateGroupMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: String!
  description: String
}

"""Autogenerated return type of CreateGroupMutation."""
type CreateGroupMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group: Group!
}

"""Autogenerated input type of CreateUserMessageChannelMutation"""
input CreateUserMessageChannelMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of CreateUserMessageChannelMutation."""
type CreateUserMessageChannelMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

type CreditCard {
  brand: String
  exp_month: String
  exp_year: String
  id: String
  last4: String
}

"""Custom badge sizes"""
enum CustomBadgeVersion {
  SMALL
  LARGE
}

"""Your account customer data"""
type Customer implements Model {
  address: Address
  can_select_lifetime: Boolean!
  created_at(relative: Boolean, format: String): String!
  credit_cards: [CreditCard!] @deprecated(reason: "Use `payment_methods` instead")
  current_period_end_at(relative: Boolean, format: String): String
  current_period_start_at(relative: Boolean, format: String): String
  default_credit_card: CreditCard @deprecated(reason: "Use `default_payment_method` instead")
  default_payment_method: PaymentMethod
  external_id: String
  id: Int!
  is_beneficiary: Boolean!
  is_canceled: Boolean!
  is_delinquent: Boolean!
  is_lifetime: Boolean!
  is_patron: Boolean!
  is_premium: Boolean!
  is_previously_premium: Boolean!
  patron: User
  payment_methods: [PaymentMethod!]
  plan: Plan
  plan_id: String
  status: String
  subscription: PremiumSubscription
  upcoming_invoice(plan_id: SupportedPlanEnum, coupon_code: String, include_tax: Boolean): Invoice
  updated_at(relative: Boolean, format: String): String!
}

enum CustomerStatuses {
  ACTIVE
  CANCELED
  INACTIVE
}

"""Defines a DateTime field/argument"""
scalar DateTime

"""A single deed"""
type Deed implements Model {
  action: String!
  bulletin_id: ID!
  connector: String
  created_at(relative: Boolean, format: String): String!
  id: Int!
  is_private: Boolean!
  is_read: Boolean!
  item: DeedKind!
  item_title(truncate: Int): String!
  owner: DeedOwner!
  parent: DeedKind
  target: DeedKind
  updated_at(relative: Boolean, format: String): String!
  user: User
}

"""A group of deeds"""
type DeedGroup {
  action: String!
  are_all_read: Boolean!
  connector: String
  created_at(relative: Boolean, format: String): String
  deeds: [Deed!]
  ids: [ID!]!
  is_private: Boolean!
  is_single: Boolean!
  item: DeedKind
  item_phrase(truncate: Int): String!
  items: [DeedKind!] @deprecated(reason: "Use `objects`")
  key: String!
  length: Int!
  object: DeedKind @deprecated(reason: "Use `item`")
  object_phrase(truncate: Int): String! @deprecated(reason: "Use `item_phrase`")
  objects: [DeedKkind!]
  owner: DeedOwner!
  target: DeedKind
  target_phrase(truncate: Int): String!
  user: User
  verb: String @deprecated(reason: "Use `action`")
}

"""Deed item, target, or parent"""
union DeedKind = Attachment | Channel | Comment | Connectable | Embed | Group | Image | Link | Text | User

"""Deed item, target, or parent"""
union DeedKkind = Attachment | Channel | Comment | Embed | Group | Image | Link | Text | User

union DeedOwner = Group | User

"""Autogenerated input type of DeleteAuthenticatedServiceMutation"""
input DeleteAuthenticatedServiceMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of DeleteAuthenticatedServiceMutation."""
type DeleteAuthenticatedServiceMutationPayload {
  authenticated_service: Authentication!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of DeleteChannelMutation"""
input DeleteChannelMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of DeleteChannelMutation."""
type DeleteChannelMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
  status: String!
}

"""Autogenerated input type of DeleteCommentMutation"""
input DeleteCommentMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of DeleteCommentMutation."""
type DeleteCommentMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  commentable: Commentable!
  status: String!
}

"""Autogenerated input type of DeleteConnectionMutation"""
input DeleteConnectionMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of DeleteConnectionMutation."""
type DeleteConnectionMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  status: String!
}

"""Autogenerated input type of DeleteGroupInviteMutation"""
input DeleteGroupInviteMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group_id: ID!
}

"""Autogenerated return type of DeleteGroupInviteMutation."""
type DeleteGroupInviteMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group: Group!
}

"""Autogenerated input type of DeleteGroupMutation"""
input DeleteGroupMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of DeleteGroupMutation."""
type DeleteGroupMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  status: String!
}

"""Dimensions for an image block"""
type Dimensions {
  height: Int
  width: Int
}

type Discount {
  coupon: Coupon
  id: String
}

"""Autogenerated input type of DismissBannerMutation"""
input DismissBannerMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  banner: BannerEnum!
}

"""Autogenerated return type of DismissBannerMutation."""
type DismissBannerMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""Autogenerated input type of DowngradeToLifetimeMutation"""
input DowngradeToLifetimeMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of DowngradeToLifetimeMutation."""
type DowngradeToLifetimeMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""An embed block"""
type Embed implements Block & ConnectableInterface & Model {
  can: BlockCan
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]
  channels_with_same_source(per: Int = 25, page: Int = 1): [Channel!]
  comments(direction: SortDirection = ASC): [Comment!] @deprecated(reason: "Channels do not have comments. Call this on Block.")

  """Returns the outer channel if we are inside of one"""
  connection: Connection
  connections: [Connection]
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String!
  current_user_channels: [Channel!]
  description(format: Format, no_links: Boolean = false): String
  embed_height: Int
  embed_html: String
  embed_width: Int
  href(absolute: Boolean = false): String
  id: Int!
  image_updated_at(relative: Boolean, format: String): String
  image_url(size: ImageVersion = DISPLAY): String
  is_muted: Boolean!
  is_nsfw: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  private_accessible_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  public_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  resized_image_url(width: Int, height: Int, quality: Int = 75, blur: Int, sharpen: Int, flatten: Boolean, fallback_format: ResizedImageFallbackFormat, downloadable: Boolean): String
  source: ConnectableSource
  source_url: String
  state: String!
  title(truncate: Int): String!
  to_s(truncate: Int): String!
  updated_at(relative: Boolean, format: String): String!
  user: User
  visibility: String
}

"""Autogenerated input type of ExportChannelMutation"""
input ExportChannelMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  format: ExportFormats!
}

"""Autogenerated return type of ExportChannelMutation."""
type ExportChannelMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  status: String!
}

enum ExportFormats {
  PDF
  HTML
  ZIP
}

"""defines search file types/extensions"""
enum ExtensionsEnum {
  AAC
  AI
  AIFF
  AVI
  BMP
  CSV
  DOC
  DOCX
  EPS
  EPUB
  FLA
  GIF
  H264
  IND
  INDD
  JPEG
  JPG
  KEY
  KML
  KMZ
  LATEX
  M4A
  MA
  MB
  MID
  MIDI
  MOV
  MP3
  MP4
  MP4V
  MPEG
  MPG
  MPG4
  NUMBERS
  OGA
  OGG
  OGV
  OTF
  PAGES
  PDF
  PGP
  PNG
  PPT
  PPTX
  PSD
  SVG
  SWA
  SWF
  TEX
  TEXI
  TEXINFO
  TFM
  TIF
  TIFF
  TORRENT
  TTC
  TTF
  TXT
  WAV
  WEBM
  WEBP
  WMA
  XLS
  XLSX
  XLT
}

"""A feed"""
type Feed {
  deeds: [Deed!]!
  groups: [DeedGroup!]!
  total: Int!
}

input Fields {
  facets: [FieldsEnum!] = [NAME]
  op: OperationEnum = OR
}

"""defines search fields"""
enum FieldsEnum {
  ALL
  NAME
  DESCRIPTION
  CONTENT
  DOMAIN
  URL
}

"""Reason for flagging a content"""
enum FlagCategoryEnum {
  NSFW
  SPAM
  OFFENSIVE
}

"""Autogenerated input type of FlagContentMutation"""
input FlagContentMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  type: BaseConnectableTypeEnum!
  category: FlagCategoryEnum!
}

"""Autogenerated return type of FlagContentMutation."""
type FlagContentMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  status: String!
}

"""Autogenerated input type of FollowMutation"""
input FollowMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  type: FollowableTypeEnum!
}

"""Autogenerated return type of FollowMutation."""
type FollowMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  followable: FollowableType!
}

"""Fields common to models that can be followed"""
interface Followable {
  followers(per: Int = 25, page: Int = 1): [User!]
  is_followed: Boolean!
  is_restricted: Boolean!
}

"""Followable object"""
union FollowableType = Channel | Group | User

"""Types of followable objects"""
enum FollowableTypeEnum {
  USER
  CHANNEL
  GROUP
}

"""Ways to filter following"""
enum FollowingTypeEnum {
  ALL
  USER
  CHANNEL
  GROUP
}

"""Ways to format a markdown field"""
enum Format {
  HTML
  MARKDOWN
}

"""A Group of Users"""
type Group implements Followable & Model {
  avatar(size: AvatarVersion): String
  can: GroupCan
  channels(per: Int = 25, page: Int = 1, q: String = null): [Channel!]

  """
  Special channel field that eager loads all the owner and does not do pagination
  """
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels!]
  counts: GroupCounts
  created_at(relative: Boolean, format: String): String!
  description(format: Format, no_links: Boolean = false): String
  feed(offset: Int = 0, limit: Int = 50, start: String = "+inf", end: String = "-inf"): Feed
  followers(per: Int = 25, page: Int = 1): [User!]
  href(absolute: Boolean = false): String
  id: Int!
  initials: String!
  invite: GroupInviteType
  is_current_user_a_member: Boolean!
  is_current_user_the_owner: Boolean!
  is_followed: Boolean!

  """Is *every* user in the group Premium?"""
  is_premium(include_owner: Boolean = false): Boolean
  is_restricted: Boolean!

  """Are *any* users in the group upgradeable to Premium?"""
  is_upgradeable(include_owner: Boolean = false): Boolean
  manageable_user_ids: [Int!]
  memberships: [GroupMembership!]
  name: String!
  slug: String!
  subscription: PremiumSubscription
  upcoming_invoice(plan_id: SupportedPlanEnum, coupon_code: String, quantity: Int): Invoice
  updated_at(relative: Boolean, format: String): String!
  user: User!
  users: [User!]
  visibility: String!
}

"""The actions that the CurrentUser can perform on the Group"""
type GroupCan {
  add_to: Boolean!
  destroy: Boolean!
  follow: Boolean!
  manage: Boolean!
  manage_users: Boolean!
  update: Boolean!
}

type GroupCounts {
  channels: Int
  followers: Int!
  users: Int
}

"""An invitation to a group"""
type GroupInviteType implements Model {
  code: String
  created_at(relative: Boolean, format: String): String!
  group: Group
  href(absolute: Boolean = false): String
  id: Int!
  updated_at(relative: Boolean, format: String): String!
}

"""A membership defining the relationship between Groups and Users"""
type GroupMembership implements Model {
  can: GroupMembershipCan
  created_at(relative: Boolean, format: String): String!
  id: Int!
  updated_at(relative: Boolean, format: String): String!
  user: User
}

"""The actions that the CurrentUser can perform on the GroupMembership"""
type GroupMembershipCan {
  manage: Boolean!
}

"""A preview of a group"""
type GroupPreview implements Model {
  avatar(size: AvatarVersion): String
  counts: GroupCounts
  created_at(relative: Boolean, format: String): String!
  description(format: Format, no_links: Boolean = false): String
  href(absolute: Boolean = false): String
  id: Int!
  initials: String
  name: String
  slug: String
  updated_at(relative: Boolean, format: String): String!
  user: User
  users: [User!]
  visibility: String
}

"""Relationship to group"""
enum GroupType {
  ALL
  OWNER
  MEMBER
}

union Identifiable = Group | User

"""An object which exposes and names Users and Groups"""
type Identity {
  identifiable: Identifiable!
  name: String!
  slug: String!
}

"""An image block"""
type Image implements Block & ConnectableInterface & Model {
  alt_text: String
  can: BlockCan
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]
  channels_with_same_source(per: Int = 25, page: Int = 1): [Channel!]
  comments(direction: SortDirection = ASC): [Comment!] @deprecated(reason: "Channels do not have comments. Call this on Block.")

  """Returns the outer channel if we are inside of one"""
  connection: Connection
  connections: [Connection]
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String!
  current_user_channels: [Channel!]
  description(format: Format, no_links: Boolean = false): String

  """URL to find the original image on various services"""
  find_original_url(service: OriginalUrlServiceEnum = GOOGLE): String
  href(absolute: Boolean = false): String
  id: Int!
  image_url(size: ImageVersion = DISPLAY): String
  is_muted: Boolean!
  is_nsfw: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  original_dimensions: Dimensions
  private_accessible_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  public_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  resized_image_url(width: Int, height: Int, quality: Int = 75, blur: Int, sharpen: Int, flatten: Boolean, fallback_format: ResizedImageFallbackFormat, downloadable: Boolean): String
  source: ConnectableSource
  state: String!
  title(truncate: Int): String!
  to_s(truncate: Int): String!
  updated_at(relative: Boolean, format: String): String!
  user: User
  visibility: String
}

"""Image sizes"""
enum ImageVersion {
  THUMB
  SQUARE
  DISPLAY
  LARGE
  ORIGINAL
}

type IndexedChannels {
  channels: [Channel!]!
  key: String!
}

enum IndexedChannelsTypes {
  OWN
  COLLABORATION
}

"""Autogenerated input type of InitiateChannelTransferMutation"""
input InitiateChannelTransferMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  owner_id: ID
  owner_type: ChannelOwnerTypeEnum
  user_id: ID
}

"""Autogenerated return type of InitiateChannelTransferMutation."""
type InitiateChannelTransferMutationPayload {
  channel_transfer_request: ChannelTransferRequest!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of InviteCollaboratorMutation"""
input InviteCollaboratorMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  channel_id: ID!
  email: String!
}

"""Autogenerated return type of InviteCollaboratorMutation."""
type InviteCollaboratorMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of InviteGroupUsersMutation"""
input InviteGroupUsersMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  emails: [String!]!
}

"""Autogenerated return type of InviteGroupUsersMutation."""
type InviteGroupUsersMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group: Group!
}

"""Autogenerated input type of InviteUsersMutation"""
input InviteUsersMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  emails: [String!]!
}

"""Autogenerated return type of InviteUsersMutation."""
type InviteUsersMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  users: [User!]!
}

"""An invited user"""
type Invitee implements Model & UserInterface {
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]

  """
  Special channel field that eager loads all the owner and does not do pagination
  """
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels!]
  contents(per: Int = 25, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: SortDirection = DESC, seed: Int = 101, q: String = null, type: ConnectableTypeEnum = null, include_group_channels: Boolean = false): [Connectable!] @deprecated(reason: "Use `channels` and `kontents` fields instead.")
  created_at(relative: Boolean, format: String): String!
  custom_badge(size: CustomBadgeVersion): String
  email: String
  first_name(truncate: Int): String!
  following(per: Int = 25, page: Int = 1, type: FollowingTypeEnum = ALL): [FollowableType!]
  groups(per: Int = 25, page: Int = 1): [Group!]
  has_had_recent_birthday: Boolean
  hidden_email: String!
  href(absolute: Boolean = false): String
  id: Int!
  initials: String!
  is_approaching_connections_limit: Boolean
  is_approaching_either_connections_limit: Boolean! @deprecated(reason: "Use is_approaching_connections_limit")
  is_canceled: Boolean!
  is_exceeding_connections_limit: Boolean
  is_exceeding_either_connections_limit: Boolean! @deprecated(reason: "Use is_exceeding_connections_limit")
  is_indexable: Boolean!
  is_investor: Boolean!
  is_lifetime_premium: Boolean!
  is_me: Boolean!
  is_premium: Boolean!
  is_supporter: Boolean!
  is_upgradeable: Boolean!
  kontents(per: Int = 25, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: SortDirection = DESC, seed: Int = 101, q: String = null, type: ConnectableTypeEnum = null, include_group_channels: Boolean = false): [Konnectable!]
  last_name(truncate: Int): String!
  name(truncate: Int): String!
  slug: String
  updated_at(relative: Boolean, format: String): String!
}

type Invoice {
  """Dicsount applied to invoice"""
  discount: Discount

  """Can be `null` in cases where there is a manually sent invoice"""
  next_payment_attempt_at(relative: Boolean, format: String): String

  """USD cents"""
  subtotal: Int

  """USD cents"""
  tax: Int
  tax_rate: TaxRate

  """USD cents"""
  total: Int
}

union Konnectable = Attachment | Channel | Embed | Image | Link | PendingBlock | Text

"""A link block"""
type Link implements Block & ConnectableInterface & Model {
  can: BlockCan
  canonical_link: CanonicalLink
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]
  channels_with_same_source(per: Int = 25, page: Int = 1): [Channel!]
  comments(direction: SortDirection = ASC): [Comment!] @deprecated(reason: "Channels do not have comments. Call this on Block.")

  """Returns the outer channel if we are inside of one"""
  connection: Connection
  connections: [Connection]
  content(format: Format, no_links: Boolean = false): String
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String!
  current_user_channels: [Channel!]
  description(format: Format, no_links: Boolean = false): String
  href(absolute: Boolean = false): String
  id: Int!
  image_updated_at(relative: Boolean, format: String): String
  image_url(size: ImageVersion = DISPLAY): String
  is_muted: Boolean!
  is_nsfw: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  private_accessible_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  public_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  resized_image_url(width: Int, height: Int, quality: Int = 75, blur: Int, sharpen: Int, flatten: Boolean, fallback_format: ResizedImageFallbackFormat, downloadable: Boolean): String
  source: ConnectableSource
  source_url: String
  state: String!
  title(truncate: Int): String!
  to_s(truncate: Int): String!
  updated_at(relative: Boolean, format: String): String!
  user: User
  visibility: String
}

"""Autogenerated input type of LoginMutation"""
input LoginMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  email: String!
  password: String!
}

"""Autogenerated return type of LoginMutation."""
type LoginMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""The current user"""
type Me implements Model & UserInterface {
  authenticated_service(provider: AuthenticatedServiceProvider = TWITTER): Authentication
  authentication_token: String
  avatar(size: AvatarVersion): String
  badge: String
  banner: BannerEnum
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]

  """
  Special channel field that eager loads all the owner and does not do pagination
  """
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels!]
  connection_search(q: String = null, per: Int = 5, page: Int = 1, include_open_channels: Boolean = true): [Channel!]
  contents(per: Int = 25, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: SortDirection = DESC, seed: Int = 101, q: String = null, type: ConnectableTypeEnum = null, include_group_channels: Boolean = false): [Connectable!] @deprecated(reason: "Use `channels` and `kontents` fields instead.")
  counts: MeCounts
  created_at(relative: Boolean, format: String): String!
  custom_badge(size: CustomBadgeVersion): String
  customer: Customer
  email: String!
  feed(type: String = "User", offset: Int = 0, limit: Int = 50, start: String = "+inf", end: String = "-inf"): Feed
  first_name(truncate: Int): String!
  flag(name: String!): Boolean!
  flags: MeFlags
  following(per: Int = 25, page: Int = 1, type: FollowingTypeEnum = ALL): [FollowableType!]
  groups(per: Int = 25, page: Int = 1, type: GroupType = ALL): [Group!]!
  has_had_recent_birthday: Boolean
  hidden_email: String!
  home_path: String
  href(absolute: Boolean = false): String
  id: Int!
  initials: String!
  is_approaching_connections_limit: Boolean
  is_approaching_either_connections_limit: Boolean! @deprecated(reason: "Use is_approaching_connections_limit")
  is_canceled: Boolean!
  is_confirmed: Boolean!
  is_exceeding_connections_limit: Boolean!
  is_exceeding_either_connections_limit: Boolean! @deprecated(reason: "Use is_exceeding_connections_limit")
  is_exceeding_private_connections_limit: Boolean! @deprecated(reason: "Use is_exceeding_connections_limit")
  is_indexable: Boolean!
  is_investor: Boolean!
  is_lifetime_premium: Boolean!
  is_me: Boolean!
  is_pending_confirmation: Boolean!
  is_pending_reconfirmation: Boolean!
  is_premium: Boolean!
  is_supporter: Boolean!
  is_upgradeable: Boolean!
  kontents(per: Int = 25, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: SortDirection = DESC, seed: Int = 101, q: String = null, type: ConnectableTypeEnum = null, include_group_channels: Boolean = false): [Konnectable!]
  last_name(truncate: Int): String!
  name(truncate: Int): String!
  non_premium_connections_limit: Int
  non_premium_private_connections_limit: Int @deprecated(reason: "Use non_premium_connections_limit")
  notifications(offset: Int = 0, limit: Int = 50, start: String = "+inf", end: String = "-inf"): Feed
  plan: String
  plans: [Plan!]

  """Manifest for uploading new files to S3"""
  policy: Policy
  post_address: String
  recent_connections(per: Int = 25): [Channel!]
  settings: MeSettings
  slug: String
  unconfirmed_email: String
  updated_at(relative: Boolean, format: String): String!
}

type MeCounts implements UserCountsInterface {
  blocks: Int
  channels: Int
  connections: Int
  connections_limit: Int
  followers: Int!
  following: Int!
  following_channels: Int!
  following_groups: Int!
  following_users: Int!
  groups: Int
  notifications: Int
  private_connections: Int @deprecated(reason: "No longer applicable")
  private_connections_limit: Int @deprecated(reason: "No longer applicable")
}

input MeFlagInput {
  name: String!
  value: Boolean!
}

type MeFlags {
  has_seen_feed_connect_twitter: Boolean
}

"""Flag keys"""
enum MeFlagsEnum {
  HAS_SEEN_FEED_CONNECT_TWITTER
}

type MeSettings {
  dark_mode: Boolean!
  exclude_from_indexes: Boolean!
  hide_notification_count: Boolean!
  include_open_channels_in_connection_search: Boolean!
  receive_editorial_emails: Boolean!
  receive_email: String!
  receive_group_premium_emails: Boolean!
  receive_newsletter: Boolean!
  receive_sunday_review_emails: Boolean!
  receive_tips_emails: Boolean!
  show_nsfw: Boolean!
  show_tour: Boolean!
}

"""Union of Channel members"""
union Member = Group | User

"""Member types"""
enum MemberTypes {
  GROUP
  USER
}

"""Fields common to all models"""
interface Model {
  created_at(relative: Boolean, format: String): String!
  id: Int!
  updated_at(relative: Boolean, format: String): String!
}

"""Autogenerated input type of MoveConnectableMutation"""
input MoveConnectableMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  channel_id: ID!
  connectable: ConnectableInput!
  action: Movements = INSERT_AT
  insert_at: Int
}

"""Autogenerated return type of MoveConnectableMutation."""
type MoveConnectableMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

enum Movements {
  INSERT_AT
  MOVE_TO_TOP
  MOVE_TO_BOTTOM
  MOVE_UP
  MOVE_DOWN
}

"""Fields common to models that can be muted"""
interface Mutable {
  is_muted: Boolean!
}

"""Mute-able object"""
union MutableType = Channel | Connectable | User

"""Objects that can be muted"""
enum MutableTypeEnum {
  BLOCK
  CHANNEL
  USER
}

type Mutation {
  accept_channel_transfer(
    """Parameters for AcceptChannelTransferMutation"""
    input: AcceptChannelTransferMutationInput!
  ): AcceptChannelTransferMutationPayload
  accept_group_invite(
    """Parameters for AcceptGroupInviteMutation"""
    input: AcceptGroupInviteMutationInput!
  ): AcceptGroupInviteMutationPayload
  accept_invitation(
    """Parameters for AcceptInvitationMutation"""
    input: AcceptInvitationMutationInput!
  ): AcceptInvitationMutationPayload
  add_channel_members(
    """Parameters for AddChannelMembersMutation"""
    input: AddChannelMembersMutationInput!
  ): AddChannelMembersMutationPayload
  add_collaborators(
    """Parameters for AddCollaboratorMutation"""
    input: AddCollaboratorMutationInput!
  ): AddCollaboratorMutationPayload @deprecated(reason: "Use `add_channel_member` instead")
  add_credit_card(
    """Parameters for AddCreditCardMutation"""
    input: AddCreditCardMutationInput!
  ): AddCreditCardMutationPayload
  add_group_users(
    """Parameters for AddGroupUsersMutation"""
    input: AddGroupUsersMutationInput!
  ): AddGroupUsersMutationPayload
  add_payment_method(
    """Parameters for AddPaymentMethodMutation"""
    input: AddPaymentMethodMutationInput!
  ): AddPaymentMethodMutationPayload
  apply_coupon_to_subscription(
    """Parameters for ApplyCouponToSubscriptionMutation"""
    input: ApplyCouponToSubscriptionMutationInput!
  ): ApplyCouponToSubscriptionMutationPayload
  cancel_channel_transfer(
    """Parameters for CancelChannelTransferMutation"""
    input: CancelChannelTransferMutationInput!
  ): CancelChannelTransferMutationPayload
  cancel_premium_subscription(
    """Parameters for CancelPremiumSubscriptionMutation"""
    input: CancelPremiumSubscriptionMutationInput!
  ): CancelPremiumSubscriptionMutationPayload
  cancel_premium_subscriptions(
    """Parameters for CancelPremiumSubscriptionsMutation"""
    input: CancelPremiumSubscriptionsMutationInput!
  ): CancelPremiumSubscriptionsMutationPayload
  clear_notifications(
    """Parameters for ClearNotificationsMutation"""
    input: ClearNotificationsMutationInput!
  ): ClearNotificationsMutationPayload
  confirm_account(
    """Parameters for ConfirmAccountMutation"""
    input: ConfirmAccountMutationInput!
  ): ConfirmAccountMutationPayload
  create_authenticated_service(
    """Parameters for CreateAuthenticatedServiceMutation"""
    input: CreateAuthenticatedServiceMutationInput!
  ): CreateAuthenticatedServiceMutationPayload
  create_block(
    """Parameters for CreateBlockMutation"""
    input: CreateBlockMutationInput!
  ): CreateBlockMutationPayload
  create_channel(
    """Parameters for CreateChannel"""
    input: CreateChannelInput!
  ): CreateChannelPayload
  create_comment(
    """Parameters for CreateCommentMutation"""
    input: CreateCommentMutationInput!
  ): CreateCommentMutationPayload
  create_connection(
    """Parameters for CreateConnectionMutation"""
    input: CreateConnectionMutationInput!
  ): CreateConnectionMutationPayload
  create_group(
    """Parameters for CreateGroupMutation"""
    input: CreateGroupMutationInput!
  ): CreateGroupMutationPayload
  create_group_invite(
    """Parameters for CreateGroupInviteMutation"""
    input: CreateGroupInviteMutationInput!
  ): CreateGroupInviteMutationPayload
  create_portal_session(
    """Parameters for CreateCustomerPortalSessionMutation"""
    input: CreateCustomerPortalSessionMutationInput!
  ): CreateCustomerPortalSessionMutationPayload
  create_user_message_channel(
    """Parameters for CreateUserMessageChannelMutation"""
    input: CreateUserMessageChannelMutationInput!
  ): CreateUserMessageChannelMutationPayload
  delete_authenticated_service(
    """Parameters for DeleteAuthenticatedServiceMutation"""
    input: DeleteAuthenticatedServiceMutationInput!
  ): DeleteAuthenticatedServiceMutationPayload
  delete_channel(
    """Parameters for DeleteChannelMutation"""
    input: DeleteChannelMutationInput!
  ): DeleteChannelMutationPayload
  delete_comment(
    """Parameters for DeleteCommentMutation"""
    input: DeleteCommentMutationInput!
  ): DeleteCommentMutationPayload
  delete_connection(
    """Parameters for DeleteConnectionMutation"""
    input: DeleteConnectionMutationInput!
  ): DeleteConnectionMutationPayload
  delete_group(
    """Parameters for DeleteGroupMutation"""
    input: DeleteGroupMutationInput!
  ): DeleteGroupMutationPayload
  delete_group_invite(
    """Parameters for DeleteGroupInviteMutation"""
    input: DeleteGroupInviteMutationInput!
  ): DeleteGroupInviteMutationPayload
  dismiss_banner(
    """Parameters for DismissBannerMutation"""
    input: DismissBannerMutationInput!
  ): DismissBannerMutationPayload
  downgrade_to_lifetime(
    """Parameters for DowngradeToLifetimeMutation"""
    input: DowngradeToLifetimeMutationInput!
  ): DowngradeToLifetimeMutationPayload
  export_channel(
    """Parameters for ExportChannelMutation"""
    input: ExportChannelMutationInput!
  ): ExportChannelMutationPayload
  flag_content(
    """Parameters for FlagContentMutation"""
    input: FlagContentMutationInput!
  ): FlagContentMutationPayload
  follow(
    """Parameters for FollowMutation"""
    input: FollowMutationInput!
  ): FollowMutationPayload
  initiate_channel_transfer(
    """Parameters for InitiateChannelTransferMutation"""
    input: InitiateChannelTransferMutationInput!
  ): InitiateChannelTransferMutationPayload
  invite_collaborator(
    """Parameters for InviteCollaboratorMutation"""
    input: InviteCollaboratorMutationInput!
  ): InviteCollaboratorMutationPayload @deprecated(reason: "Use `invite_channel_member` instead")
  invite_group_users(
    """Parameters for InviteGroupUsersMutation"""
    input: InviteGroupUsersMutationInput!
  ): InviteGroupUsersMutationPayload
  invite_users(
    """Parameters for InviteUsersMutation"""
    input: InviteUsersMutationInput!
  ): InviteUsersMutationPayload
  login(
    """Parameters for LoginMutation"""
    input: LoginMutationInput!
  ): LoginMutationPayload
  move_connectable_mutation(
    """Parameters for MoveConnectableMutation"""
    input: MoveConnectableMutationInput!
  ): MoveConnectableMutationPayload
  mute(
    """Parameters for MuteMutation"""
    input: MuteMutationInput!
  ): MuteMutationPayload
  mute_channel(
    """Parameters for MuteChannelMutation"""
    input: MuteChannelMutationInput!
  ): MuteChannelMutationPayload @deprecated(reason: "Use `mute` instead")
  read_notification(
    """Parameters for ReadNotificationMutation"""
    input: ReadNotificationMutationInput!
  ): ReadNotificationMutationPayload
  regenerate_canonical_link(
    """Parameters for RegenerateCanonicalLinkMutation"""
    input: RegenerateCanonicalLinkMutationInput!
  ): RegenerateCanonicalLinkMutationPayload
  registration(
    """Parameters for RegistrationMutation"""
    input: RegistrationMutationInput!
  ): RegistrationMutationPayload
  reject_channel_transfer(
    """Parameters for RejectChannelTransferMutation"""
    input: RejectChannelTransferMutationInput!
  ): RejectChannelTransferMutationPayload
  remove_channel_members(
    """Parameters for RemoveChannelMembersMutation"""
    input: RemoveChannelMembersMutationInput!
  ): RemoveChannelMembersMutationPayload
  remove_collaborators(
    """Parameters for RemoveCollaboratorsMutation"""
    input: RemoveCollaboratorsMutationInput!
  ): RemoveCollaboratorsMutationPayload @deprecated(reason: "Use `remove_channel_member` instead")
  remove_connection(
    """Parameters for RemoveConnectionMutation"""
    input: RemoveConnectionMutationInput!
  ): RemoveConnectionMutationPayload
  remove_credit_card(
    """Parameters for RemoveCreditCardMutation"""
    input: RemoveCreditCardMutationInput!
  ): RemoveCreditCardMutationPayload
  remove_group_users(
    """Parameters for RemoveGroupUsersMutation"""
    input: RemoveGroupUsersMutationInput!
  ): RemoveGroupUsersMutationPayload
  remove_payment_method(
    """Parameters for RemovePaymentMethodMutation"""
    input: RemovePaymentMethodMutationInput!
  ): RemovePaymentMethodMutationPayload
  request_password_reset(
    """Parameters for RequestPasswordResetMutation"""
    input: RequestPasswordResetMutationInput!
  ): RequestPasswordResetMutationPayload
  rerun_block_remote_processing(
    """Parameters for RerunBlockRemoteProcessingMutation"""
    input: RerunBlockRemoteProcessingMutationInput!
  ): RerunBlockRemoteProcessingMutationPayload
  resend_confirmation_email(
    """Parameters for ResendConfirmationEmailMutation"""
    input: ResendConfirmationEmailMutationInput!
  ): ResendConfirmationEmailMutationPayload
  resend_logged_out_confirmation_email(
    """Parameters for ResendLoggedOutConfirmationEmailMutation"""
    input: ResendLoggedOutConfirmationEmailMutationInput!
  ): ResendLoggedOutConfirmationEmailMutationPayload
  reset_password(
    """Parameters for ResetPasswordMutation"""
    input: ResetPasswordMutationInput!
  ): ResetPasswordMutationPayload
  restrict(
    """Parameters for RestrictMutation"""
    input: RestrictMutationInput!
  ): RestrictMutationPayload
  set_me_flags(
    """Parameters for SetMeFlagsMutation"""
    input: SetMeFlagsMutationInput!
  ): SetMeFlagsMutationPayload
  setup_incomplete_subscription(
    """Parameters for SetupIncompleteSubscriptionMutation"""
    input: SetupIncompleteSubscriptionMutationInput!
  ): SetupIncompleteSubscriptionMutationPayload
  setup_incomplete_subscription_for_group(
    """Parameters for SetupIncompleteSubscriptionForGroupMutation"""
    input: SetupIncompleteSubscriptionForGroupMutationInput!
  ): SetupIncompleteSubscriptionForGroupMutationPayload
  share_channel(
    """Parameters for ShareChannelMutation"""
    input: ShareChannelMutationInput!
  ): ShareChannelMutationPayload
  subscribe_to_newsletter(
    """Parameters for SubscribeToNewsletterMutation"""
    input: SubscribeToNewsletterMutationInput!
  ): SubscribeToNewsletterMutationPayload
  subscribe_to_premium(
    """Parameters for SubscribeToPremiumMutation"""
    input: SubscribeToPremiumMutationInput!
  ): SubscribeToPremiumMutationPayload
  subscribe_to_premium_for_users(
    """Parameters for SubscribeToPremiumForUsersMutation"""
    input: SubscribeToPremiumForUsersMutationInput!
  ): SubscribeToPremiumForUsersMutationPayload
  subscribe_to_premium_with_optional_token(
    """Parameters for SubscribeToPremiumWithOptionalTokenMutation"""
    input: SubscribeToPremiumWithOptionalTokenMutationInput!
  ): SubscribeToPremiumWithOptionalTokenMutationPayload
  toggle_connection_selection(
    """Parameters for ToggleConnectionSelectionMutation"""
    input: ToggleConnectionSelectionMutationInput!
  ): ToggleConnectionSelectionMutationPayload
  unfollow(
    """Parameters for UnfollowMutation"""
    input: UnfollowMutationInput!
  ): UnfollowMutationPayload
  unmute(
    """Parameters for UnmuteMutation"""
    input: UnmuteMutationInput!
  ): UnmuteMutationPayload
  unmute_channel(
    """Parameters for UnmuteChannelMutation"""
    input: UnmuteChannelMutationInput!
  ): UnmuteChannelMutationPayload @deprecated(reason: "Use `unmute` instead")
  update_account(
    """Parameters for UpdateAccountMutation"""
    input: UpdateAccountMutationInput!
  ): UpdateAccountMutationPayload
  update_address(
    """Parameters for UpdateAddressMutation"""
    input: UpdateAddressMutationInput!
  ): UpdateAddressMutationPayload
  update_block(
    """Parameters for UpdateBlockMutation"""
    input: UpdateBlockMutationInput!
  ): UpdateBlockMutationPayload
  update_block_thumbnail(
    """Parameters for UpdateBlockThumbnailMutation"""
    input: UpdateBlockThumbnailMutationInput!
  ): UpdateBlockThumbnailMutationPayload
  update_channel(
    """Parameters for UpdateChannelMutation"""
    input: UpdateChannelMutationInput!
  ): UpdateChannelMutationPayload
  update_customer(
    """Parameters for UpdateCustomerMutation"""
    input: UpdateCustomerMutationInput!
  ): UpdateCustomerMutationPayload
  update_flag(
    """Parameters for UpdateFlagMutation"""
    input: UpdateFlagMutationInput!
  ): UpdateFlagMutationPayload @deprecated(reason: "Use `set_me_flags` instead")
  update_group(
    """Parameters for UpdateGroupMutation"""
    input: UpdateGroupMutationInput!
  ): UpdateGroupMutationPayload
  update_incomplete_subscription(
    """Parameters for UpdateIncompleteSubscriptionMutation"""
    input: UpdateIncompleteSubscriptionMutationInput!
  ): UpdateIncompleteSubscriptionMutationPayload
  update_incomplete_subscription_for_group(
    """Parameters for UpdateIncompleteSubscriptionForGroupMutation"""
    input: UpdateIncompleteSubscriptionForGroupMutationInput!
  ): UpdateIncompleteSubscriptionForGroupMutationPayload
}

"""Autogenerated input type of MuteChannelMutation"""
input MuteChannelMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of MuteChannelMutation."""
type MuteChannelMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of MuteMutation"""
input MuteMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  type: MutableTypeEnum!
}

"""Autogenerated return type of MuteMutation."""
type MuteMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  mutable: MutableType!
}

"""Newsletters that can be subscribed to"""
enum NewsletterListEnum {
  """General newsletter"""
  GENERAL

  """Editorial newsletter"""
  EDITORIAL
}

"""defines logical operation"""
enum OperationEnum {
  AND
  OR
}

input Order {
  facet: SortOrderEnum = SCORE
  dir: SortDirection = DESC
}

"""various services to find the original image"""
enum OriginalUrlServiceEnum {
  BING
  GOOGLE
}

type PaymentMethod {
  card: CreditCard
  id: String
  postal_code: String
}

"""A block which has not yet found its calling"""
type PendingBlock implements Block & ConnectableInterface & Model {
  can: BlockCan
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]
  channels_with_same_source(per: Int = 25, page: Int = 1): [Channel!]
  comments(direction: SortDirection = ASC): [Comment!] @deprecated(reason: "Channels do not have comments. Call this on Block.")

  """Returns the outer channel if we are inside of one"""
  connection: Connection
  connections: [Connection]
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String!
  current_user_channels: [Channel!]
  description(format: Format, no_links: Boolean = false): String
  href(absolute: Boolean = false): String
  id: Int!
  is_muted: Boolean!
  is_nsfw: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  private_accessible_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  public_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  remote_source_url: String
  source: ConnectableSource
  source_title: String
  source_url: String
  state: String!
  title(truncate: Int): String!
  to_s(truncate: Int): String!
  updated_at(relative: Boolean, format: String): String!
  user: User
  visibility: String
}

type Plan {
  """USD cents"""
  amount: Float
  external_id: String
  id: ID!
  is_hidden: Boolean
  period_end_at(relative: Boolean, format: String): String
  period_start_at(relative: Boolean, format: String): String
  term: String
}

"""A policy"""
type Policy {
  AWSAccessKeyId: String!
  acl: String!
  bucket: String!
  expires: String!
  key: String
  policy: String!
  signature: String!
  success_action_status: String!
}

type PremiumSubscription {
  canceled_at(relative: Boolean, format: String): String
  current_period_end_at(relative: Boolean, format: String): String
  current_period_start_at(relative: Boolean, format: String): String
  id: ID!
  is_canceled: Boolean!
  plan: Plan
  plan_id: String!
  users(status: CustomerStatuses = ACTIVE): [User!]
}

"""The query root for this schema"""
type Query {
  block(id: ID!): Connectable @deprecated(reason: "Use `blokk` until this can be replaced with it")
  blokk(id: ID!): Konnectable

  """A single channel"""
  channel(id: ID!): Channel

  """Multiple channels"""
  channels(ids: [ID]!): [Channel]
  connection(id: ID!): Connection
  coupon(code: String!): Coupon
  explore(per: Int = 25, page: Int = 1, sort_by: SearchSorts = null, direction: SortDirection = DESC, type: SearchType, block_filter: BlockFilterEnum = null, timestamp: DateTime): [SearchResult!]
  exxplore(per: Int = 25, page: Int = 1, sort_by: SearchSorts = null, direction: SortDirection = DESC, seed: Int = 101, type: SearchType, block_filter: BlockFilterEnum = null, timestamp: DateTime): [Konnectable!]

  """Interface for getting the follow status of users or channels"""
  followable(id: ID, type: FollowableTypeEnum): FollowableType
  group(id: ID!): Group
  group_by_code(code: String!): GroupPreview
  identity(id: ID!): Identity

  """Locates the invited user through their invitation token"""
  invitee(invitation_token: String!): Invitee

  """The current logged in user"""
  me: Me

  """Interface for getting the mute status of blocks or channels"""
  mutable(id: ID!, type: MutableTypeEnum!): MutableType

  """Locates the user through their reset password token"""
  password_resettable_user(reset_password_token: String!): User
  password_token(token: ID!): User
  plans: [Plan!]
  random_title: String
  search(per: Int = 25, page: Int = 1, sort_by: SearchSorts = null, direction: SortDirection = DESC, seed: Int = 101, q: String!, type: SearchType = null): [SearchResult!]
  searches: Searches

  """An otherwise private channel that is accessible via the shared token"""
  shared_channel(token: String!): Channel
  ssearch(per: Int = 25, page: Int = 1, sort_by: SearchSorts = null, direction: SortDirection = DESC, seed: Int = 101, q: String!, type: [SsearchType] = [USER, GROUP, CHANNEL, BLOCK], block_filter: BlockFilterEnum = null): [SsearchResult!]

  """Is this endpoint operational?"""
  status: String

  """A single user"""
  user(id: ID!): User
}

"""Possible types for quick search results"""
union QuickSearchResult = Channel | Group | User

"""Autogenerated input type of ReadNotificationMutation"""
input ReadNotificationMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  notification_id: ID!
}

"""Autogenerated return type of ReadNotificationMutation."""
type ReadNotificationMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  deed: Deed!
}

"""Autogenerated input type of RegenerateCanonicalLinkMutation"""
input RegenerateCanonicalLinkMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  block_id: ID!
}

"""Autogenerated return type of RegenerateCanonicalLinkMutation."""
type RegenerateCanonicalLinkMutationPayload {
  blokk: Konnectable!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of RegistrationMutation"""
input RegistrationMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  first_name: String!
  last_name: String!
  email: String!
  password: String!
  password_confirmation: String!
  receive_newsletter: Boolean
  receive_tips_emails: Boolean
  receive_editorial_emails: Boolean
  validation_token: String
}

"""Autogenerated return type of RegistrationMutation."""
type RegistrationMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""Autogenerated input type of RejectChannelTransferMutation"""
input RejectChannelTransferMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: String!
}

"""Autogenerated return type of RejectChannelTransferMutation."""
type RejectChannelTransferMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of RemoveChannelMembersMutation"""
input RemoveChannelMembersMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  members: [ChannelMemberInput!]!
}

"""Autogenerated return type of RemoveChannelMembersMutation."""
type RemoveChannelMembersMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of RemoveCollaboratorsMutation"""
input RemoveCollaboratorsMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  channel_id: ID!
  user_ids: [ID]!
}

"""Autogenerated return type of RemoveCollaboratorsMutation."""
type RemoveCollaboratorsMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of RemoveConnectionMutation"""
input RemoveConnectionMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  connectable_id: ID!
  connectable_type: BaseConnectableTypeEnum!
  channel_id: ID!
}

"""Autogenerated return type of RemoveConnectionMutation."""
type RemoveConnectionMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  status: String!
}

"""Autogenerated input type of RemoveCreditCardMutation"""
input RemoveCreditCardMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: String!
}

"""Autogenerated return type of RemoveCreditCardMutation."""
type RemoveCreditCardMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customer: Customer!
}

"""Autogenerated input type of RemoveGroupUsersMutation"""
input RemoveGroupUsersMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  user_ids: [ID]!
}

"""Autogenerated return type of RemoveGroupUsersMutation."""
type RemoveGroupUsersMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group: Group!
}

"""Autogenerated input type of RemovePaymentMethodMutation"""
input RemovePaymentMethodMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: String!
}

"""Autogenerated return type of RemovePaymentMethodMutation."""
type RemovePaymentMethodMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customer: Customer!
}

"""Autogenerated input type of RequestPasswordResetMutation"""
input RequestPasswordResetMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  email: String!
}

"""Autogenerated return type of RequestPasswordResetMutation."""
type RequestPasswordResetMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  email: String!
}

"""Autogenerated input type of RerunBlockRemoteProcessingMutation"""
input RerunBlockRemoteProcessingMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of RerunBlockRemoteProcessingMutation."""
type RerunBlockRemoteProcessingMutationPayload {
  block: Connectable!
  blokk: Konnectable!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of ResendConfirmationEmailMutation"""
input ResendConfirmationEmailMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated return type of ResendConfirmationEmailMutation."""
type ResendConfirmationEmailMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""Autogenerated input type of ResendLoggedOutConfirmationEmailMutation"""
input ResendLoggedOutConfirmationEmailMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  email: String
}

"""Autogenerated return type of ResendLoggedOutConfirmationEmailMutation."""
type ResendLoggedOutConfirmationEmailMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  status: String!
}

"""Autogenerated input type of ResetPasswordMutation"""
input ResetPasswordMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  token: String!
  password: String!
  password_confirmation: String!
}

"""Autogenerated return type of ResetPasswordMutation."""
type ResetPasswordMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""Fallback format for resized images"""
enum ResizedImageFallbackFormat {
  JPEG
  PNG
}

"""Autogenerated input type of RestrictMutation"""
input RestrictMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of RestrictMutation."""
type RestrictMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  user: User!
}

"""Possible types for search results"""
union SearchResult = Channel | Connectable | Group | User

"""Ways to sort blocks"""
enum SearchSorts {
  CREATED_AT
  UPDATED_AT
  RANDOM
  FOLLOWER_COUNT
  ALPHA
  LENGTH
  DEFAULT
}

"""Ways to filter search by type"""
enum SearchType {
  ALL
  USER
  CHANNEL
  CONNECTABLE
}

type Searches {
  advanced(term: Term = {facet: "*", op: AND}, where: [Where!] = [{facet: ALL}], what: What = {facets: [ALL], op: OR}, fields: Fields = {facets: [NAME], op: OR}, extensions: [ExtensionsEnum!] = [], order: Order = {facet: SCORE, dir: DESC}, period: String, after: String, before: String, per: Int = 24, page: Int = 1, seed: Int = 1681245501): AdvancedResult!
  collaborators(query: String!, types: [SearchesCollaboratorsType!] = [USER, GROUP], limit: Int = 10): [Member!]
  quick(query: String!, limit: Int = 6, type: [SsearchType] = [USER, GROUP, CHANNEL]): [QuickSearchResult!]
}

enum SearchesCollaboratorsType {
  USER
  GROUP
}

"""Autogenerated input type of SetMeFlagsMutation"""
input SetMeFlagsMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  flags: [MeFlagInput]
}

"""Autogenerated return type of SetMeFlagsMutation."""
type SetMeFlagsMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""
Autogenerated input type of SetupIncompleteSubscriptionForGroupMutation
"""
input SetupIncompleteSubscriptionForGroupMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ID of Group that users are a member of"""
  group_id: ID!

  """IDs of Users that this subscription should apply to"""
  user_ids: [ID]!
  plan_id: SupportedPlanEnum!
  coupon_code: String
}

"""
Autogenerated return type of SetupIncompleteSubscriptionForGroupMutation.
"""
type SetupIncompleteSubscriptionForGroupMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  client_secret: String
  subscription: StripeSubscription
}

"""Autogenerated input type of SetupIncompleteSubscriptionMutation"""
input SetupIncompleteSubscriptionMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  plan_id: SupportedPlanEnum!
  coupon_code: String
}

"""Autogenerated return type of SetupIncompleteSubscriptionMutation."""
type SetupIncompleteSubscriptionMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  client_secret: String
  subscription: StripeSubscription
}

"""Autogenerated input type of ShareChannelMutation"""
input ShareChannelMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  enable: Boolean!
}

"""Autogenerated return type of ShareChannelMutation."""
type ShareChannelMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""A spooky connectable"""
type SkeletalConnectable {
  id: Int!
  type: String!
}

"""Directions to sort blocks"""
enum SortDirection {
  ASC
  DESC
}

"""Ways to sort Advanced Search results"""
enum SortOrderEnum {
  SCORE
  NAME
  CREATED_AT
  UPDATED_AT
  RANDOM
  CONNECTIONS_COUNT
}

"""Ways to sort blocks"""
enum Sorts {
  POSITION
  CREATED_AT
  UPDATED_AT
}

"""Possible types for search results"""
union SsearchResult = Attachment | Channel | Embed | Group | Image | Link | PendingBlock | Text | User

"""Ways to filter search by type"""
enum SsearchType {
  USER
  CHANNEL
  BLOCK
  GROUP
}

type StripeSubscription {
  cancel_at_period_end: Boolean!
  canceled_at(relative: Boolean, format: String): String
  current_period_end_at(relative: Boolean, format: String): String
  current_period_start_at(relative: Boolean, format: String): String
  customer: Customer!
  id: ID!
  invoice: Invoice
  status: String!
}

"""Autogenerated input type of SubscribeToNewsletterMutation"""
input SubscribeToNewsletterMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  email: String!
  list: NewsletterListEnum = GENERAL
}

"""Autogenerated return type of SubscribeToNewsletterMutation."""
type SubscribeToNewsletterMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  status: String!
}

"""Autogenerated input type of SubscribeToPremiumForUsersMutation"""
input SubscribeToPremiumForUsersMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """ID of Group that users are a member of"""
  group_id: ID!

  """IDs of Users that this subscription should apply to"""
  user_ids: [ID]!

  """Tokenized card/card ID from Stripe"""
  token: String!
  plan_id: SupportedPlanEnum!
  coupon_code: String
}

"""Autogenerated return type of SubscribeToPremiumForUsersMutation."""
type SubscribeToPremiumForUsersMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group: Group!
  me: Me!
  users: [User!]!
}

"""Autogenerated input type of SubscribeToPremiumMutation"""
input SubscribeToPremiumMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Tokenized card from Stripe"""
  token: String!
  plan_id: SupportedPlanEnum!
  coupon_code: String
  subscription_source: SubscriptionSourceEnum = WEB
}

"""Autogenerated return type of SubscribeToPremiumMutation."""
type SubscribeToPremiumMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""
Autogenerated input type of SubscribeToPremiumWithOptionalTokenMutation
"""
input SubscribeToPremiumWithOptionalTokenMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String

  """Tokenized card from Stripe"""
  token: String
  plan_id: SupportedPlanEnum!
  coupon_code: String
  subscription_source: SubscriptionSourceEnum = WEB
}

"""
Autogenerated return type of SubscribeToPremiumWithOptionalTokenMutation.
"""
type SubscribeToPremiumWithOptionalTokenMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""Possible places a person may upgrade to premium from"""
enum SubscriptionSourceEnum {
  WEB
  MOBILE
}

"""Subscription plans that are purchaseable by users"""
enum SupportedPlanEnum {
  MONTHLY
  YEARLY
  PLUS_YEARLY
}

type TaxRate {
  country: String
  description: String
  display_name: String
  id: String
  jurisdiction: String
  percentage: Float
  state: String
}

input Term {
  facet: String = "*"
  op: OperationEnum = AND
}

"""A text block"""
type Text implements Block & ConnectableInterface & Model {
  can: BlockCan
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]
  channels_with_same_source(per: Int = 25, page: Int = 1): [Channel!]
  comments(direction: SortDirection = ASC): [Comment!] @deprecated(reason: "Channels do not have comments. Call this on Block.")

  """Returns the outer channel if we are inside of one"""
  connection: Connection
  connections: [Connection]
  content(format: Format, no_links: Boolean = false): String!
  counts: BlockCounts
  created_at(relative: Boolean, format: String): String!
  current_user_channels: [Channel!]
  description(format: Format, no_links: Boolean = false): String

  """URL to find the original image on various services"""
  find_original_url(service: OriginalUrlServiceEnum = GOOGLE): String
  href(absolute: Boolean = false): String
  id: Int!
  is_muted: Boolean!
  is_nsfw: Boolean
  kind: ConnectableKind @deprecated(reason: "Avoid using if at all possible")
  klass: String
  private_accessible_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  public_channels(per: Int = 25, page: Int = 1, direction: SortDirection = DESC): [Channel!]
  source: ConnectableSource
  state: String!
  title(truncate: Int): String!
  to_s(truncate: Int): String!
  updated_at(relative: Boolean, format: String): String!
  user: User
  visibility: String
}

"""Autogenerated input type of ToggleConnectionSelectionMutation"""
input ToggleConnectionSelectionMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of ToggleConnectionSelectionMutation."""
type ToggleConnectionSelectionMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  connection: Connection!
}

"""Autogenerated input type of UnfollowMutation"""
input UnfollowMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  type: FollowableTypeEnum!
}

"""Autogenerated return type of UnfollowMutation."""
type UnfollowMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  followable: FollowableType!
}

"""Autogenerated input type of UnmuteChannelMutation"""
input UnmuteChannelMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
}

"""Autogenerated return type of UnmuteChannelMutation."""
type UnmuteChannelMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of UnmuteMutation"""
input UnmuteMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  type: MutableTypeEnum!
}

"""Autogenerated return type of UnmuteMutation."""
type UnmuteMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  mutable: MutableType!
}

"""Autogenerated input type of UpdateAccountMutation"""
input UpdateAccountMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  email: String
  first_name: String
  last_name: String
  home_path: String
  receive_email: String
  receive_newsletter: Boolean
  receive_tips_emails: Boolean
  receive_editorial_emails: Boolean
  receive_group_premium_emails: Boolean
  receive_sunday_review_emails: Boolean
  hide_notification_count: Boolean
  include_open_channels_in_connection_search: Boolean
  dark_mode: Boolean
  show_tour: Boolean
  show_nsfw: Boolean
  exclude_from_indexes: Boolean
  bio: String
  avatar_url: String
  custom_badge_url: String
  password: String
  password_confirmation: String
}

"""Autogenerated return type of UpdateAccountMutation."""
type UpdateAccountMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  me: Me!
}

"""Autogenerated input type of UpdateAddressMutation"""
input UpdateAddressMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  line1: String
  line2: String
  city: String
  state: String
  postal_code: String
  country: String
}

"""Autogenerated return type of UpdateAddressMutation."""
type UpdateAddressMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customer: Customer
}

"""Autogenerated input type of UpdateBlockMutation"""
input UpdateBlockMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  title: String
  description: String
  content: String
  alt_text: String
}

"""Autogenerated return type of UpdateBlockMutation."""
type UpdateBlockMutationPayload {
  block: Connectable!
  blokk: Konnectable!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of UpdateBlockThumbnailMutation"""
input UpdateBlockThumbnailMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  image_url: String!
}

"""Autogenerated return type of UpdateBlockThumbnailMutation."""
type UpdateBlockThumbnailMutationPayload {
  block: Connectable!
  blokk: Konnectable!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of UpdateChannelMutation"""
input UpdateChannelMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  title: String
  visibility: ChannelVisibility
  description: String
  content_flag: ContentFlag
  owner: ChannelMemberInput
}

"""Autogenerated return type of UpdateChannelMutation."""
type UpdateChannelMutationPayload {
  channel: Channel!

  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
}

"""Autogenerated input type of UpdateCustomerMutation"""
input UpdateCustomerMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  default_credit_card_id: String
  default_payment_method_id: String
}

"""Autogenerated return type of UpdateCustomerMutation."""
type UpdateCustomerMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  customer: Customer!
}

"""Autogenerated input type of UpdateFlagMutation"""
input UpdateFlagMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  name: MeFlagsEnum!
  value: Boolean!
}

"""Autogenerated return type of UpdateFlagMutation."""
type UpdateFlagMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  flags: MeFlags!
}

"""Autogenerated input type of UpdateGroupMutation"""
input UpdateGroupMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  id: ID!
  name: String
  description: String
  avatar_url: String
}

"""Autogenerated return type of UpdateGroupMutation."""
type UpdateGroupMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  group: Group!
}

"""
Autogenerated input type of UpdateIncompleteSubscriptionForGroupMutation
"""
input UpdateIncompleteSubscriptionForGroupMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  plan_id: SupportedPlanEnum
  coupon_code: String
  subscription_id: String!

  """ID of Group that users are a member of"""
  group_id: ID!

  """IDs of Users that this subscription should apply to"""
  user_ids: [ID]!
}

"""
Autogenerated return type of UpdateIncompleteSubscriptionForGroupMutation.
"""
type UpdateIncompleteSubscriptionForGroupMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  subscription: StripeSubscription
}

"""Autogenerated input type of UpdateIncompleteSubscriptionMutation"""
input UpdateIncompleteSubscriptionMutationInput {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  plan_id: SupportedPlanEnum
  coupon_code: String
  subscription_id: String!
}

"""Autogenerated return type of UpdateIncompleteSubscriptionMutation."""
type UpdateIncompleteSubscriptionMutationPayload {
  """A unique identifier for the client performing the mutation."""
  clientMutationId: String
  subscription: StripeSubscription
}

"""A single user"""
type User implements Followable & Model & Mutable & UserInterface {
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]

  """
  Special channel field that eager loads all the owner and does not do pagination
  """
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels!]
  contents(per: Int = 25, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: SortDirection = DESC, seed: Int = 101, q: String = null, type: ConnectableTypeEnum = null, include_group_channels: Boolean = false): [Connectable!] @deprecated(reason: "Use `channels` and `kontents` fields instead.")
  counts: UserCounts
  created_at(relative: Boolean, format: String): String!
  custom_badge(size: CustomBadgeVersion): String
  first_name(truncate: Int): String!
  followers(per: Int = 25, page: Int = 1): [User!]
  following(per: Int = 25, page: Int = 1, type: FollowingTypeEnum = ALL): [FollowableType!]
  groups(per: Int = 25, page: Int = 1): [Group!]
  has_had_recent_birthday: Boolean
  hidden_email: String!
  href(absolute: Boolean = false): String
  id: Int!
  initials: String!
  is_approaching_connections_limit: Boolean
  is_approaching_either_connections_limit: Boolean! @deprecated(reason: "Use is_approaching_connections_limit")
  is_canceled: Boolean!
  is_exceeding_connections_limit: Boolean
  is_exceeding_either_connections_limit: Boolean! @deprecated(reason: "Use is_exceeding_connections_limit")
  is_followed: Boolean!
  is_indexable: Boolean!
  is_investor: Boolean!
  is_lifetime_premium: Boolean!
  is_me: Boolean!
  is_muted: Boolean!
  is_premium: Boolean!
  is_restricted: Boolean!
  is_supporter: Boolean!
  is_upgradeable: Boolean!
  kontents(per: Int = 25, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: SortDirection = DESC, seed: Int = 101, q: String = null, type: ConnectableTypeEnum = null, include_group_channels: Boolean = false): [Konnectable!]
  last_name(truncate: Int): String!
  name(truncate: Int): String!
  slug: String
  updated_at(relative: Boolean, format: String): String!
}

"""The actions that the CurrentUser can perform on the User"""
type UserCan {
  cancel_premium: Boolean!
  edit_profile_description: Boolean!
  follow: Boolean!
  manage: Boolean!
  message: Boolean!
  set_custom_badge: Boolean!
}

type UserCounts implements UserCountsInterface {
  blocks: Int
  channels: Int
  connections: Int
  followers: Int!
  following: Int!
  following_channels: Int!
  following_groups: Int!
  following_users: Int!
  groups: Int
}

interface UserCountsInterface {
  blocks: Int
  channels: Int
  connections: Int
  followers: Int!
  following: Int!
  following_channels: Int!
  following_groups: Int!
  following_users: Int!
  groups: Int
}

"""Fields common to all users"""
interface UserInterface {
  avatar(size: AvatarVersion): String
  badge: String
  bio(format: Format, no_links: Boolean = false): String
  can: UserCan
  channels(per: Int = 25, page: Int = 1, sort_by: ChannelsSort = ADDED_TO_AT, direction: SortDirection = DESC): [Channel!]

  """
  Special channel field that eager loads all the owner and does not do pagination
  """
  channels_index(type: IndexedChannelsTypes = OWN): [IndexedChannels!]
  contents(per: Int = 25, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: SortDirection = DESC, seed: Int = 101, q: String = null, type: ConnectableTypeEnum = null, include_group_channels: Boolean = false): [Connectable!] @deprecated(reason: "Use `channels` and `kontents` fields instead.")
  custom_badge(size: CustomBadgeVersion): String
  first_name(truncate: Int): String!
  following(per: Int = 25, page: Int = 1, type: FollowingTypeEnum = ALL): [FollowableType!]
  groups(per: Int = 25, page: Int = 1): [Group!]
  has_had_recent_birthday: Boolean
  hidden_email: String!
  href(absolute: Boolean = false): String
  initials: String!
  is_approaching_connections_limit: Boolean
  is_approaching_either_connections_limit: Boolean! @deprecated(reason: "Use is_approaching_connections_limit")
  is_canceled: Boolean!
  is_exceeding_connections_limit: Boolean
  is_exceeding_either_connections_limit: Boolean! @deprecated(reason: "Use is_exceeding_connections_limit")
  is_indexable: Boolean!
  is_investor: Boolean!
  is_lifetime_premium: Boolean!
  is_me: Boolean!
  is_premium: Boolean!
  is_supporter: Boolean!
  is_upgradeable: Boolean!
  kontents(per: Int = 25, page: Int = 1, sort_by: SearchSorts = UPDATED_AT, direction: SortDirection = DESC, seed: Int = 101, q: String = null, type: ConnectableTypeEnum = null, include_group_channels: Boolean = false): [Konnectable!]
  last_name(truncate: Int): String!
  name(truncate: Int): String!
  slug: String
}

input What {
  facets: [WhatEnum!] = [ALL]
  op: OperationEnum = OR
}

"""defines for what searched"""
enum WhatEnum {
  ALL
  BLOCK
  CHANNEL
  GROUP
  USER
  ATTACHMENT
  IMAGE
  LINK
  MEDIA
  TEXT
}

input Where {
  facet: WhereEnum = ALL
  id: ID
}

"""defines search space"""
enum WhereEnum {
  ALL
  MY
  FOLLOWING
  USER
  GROUP
  CHANNEL
}
