export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = {
	[K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
	[SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
	[SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
	ID: string;
	String: string;
	Boolean: boolean;
	Int: number;
	Float: number;
	/** Defines a DateTime field/argument */
	DateTime: any;
};

/** Autogenerated input type of AcceptChannelTransferMutation */
export type AcceptChannelTransferMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	token: Scalars["String"];
};

/** Autogenerated return type of AcceptChannelTransferMutation. */
export type AcceptChannelTransferMutationPayload = {
	__typename?: "AcceptChannelTransferMutationPayload";
	channel_transfer_request: ChannelTransferRequest;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of AcceptGroupInviteMutation */
export type AcceptGroupInviteMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	code: Scalars["String"];
};

/** Autogenerated return type of AcceptGroupInviteMutation. */
export type AcceptGroupInviteMutationPayload = {
	__typename?: "AcceptGroupInviteMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	group: Group;
};

/** Autogenerated input type of AcceptInvitationMutation */
export type AcceptInvitationMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	invitation_token: Scalars["String"];
	first_name: Scalars["String"];
	last_name: Scalars["String"];
	email: Scalars["String"];
	password: Scalars["String"];
	password_confirmation: Scalars["String"];
	receive_newsletter?: InputMaybe<Scalars["Boolean"]>;
	receive_tips_emails?: InputMaybe<Scalars["Boolean"]>;
	receive_editorial_emails?: InputMaybe<Scalars["Boolean"]>;
	validation_token?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of AcceptInvitationMutation. */
export type AcceptInvitationMutationPayload = {
	__typename?: "AcceptInvitationMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me?: Maybe<Me>;
};

/** Autogenerated input type of AddChannelMembersMutation */
export type AddChannelMembersMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	members: Array<ChannelMemberInput>;
};

/** Autogenerated return type of AddChannelMembersMutation. */
export type AddChannelMembersMutationPayload = {
	__typename?: "AddChannelMembersMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of AddCollaboratorMutation */
export type AddCollaboratorMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	channel_id: Scalars["ID"];
	user_ids: Array<InputMaybe<Scalars["ID"]>>;
};

/** Autogenerated return type of AddCollaboratorMutation. */
export type AddCollaboratorMutationPayload = {
	__typename?: "AddCollaboratorMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of AddCreditCardMutation */
export type AddCreditCardMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	token: Scalars["String"];
	default_source?: InputMaybe<Scalars["Boolean"]>;
};

/** Autogenerated return type of AddCreditCardMutation. */
export type AddCreditCardMutationPayload = {
	__typename?: "AddCreditCardMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	customer: Customer;
};

/** Autogenerated input type of AddGroupUsersMutation */
export type AddGroupUsersMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	user_ids: Array<InputMaybe<Scalars["ID"]>>;
};

/** Autogenerated return type of AddGroupUsersMutation. */
export type AddGroupUsersMutationPayload = {
	__typename?: "AddGroupUsersMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	group: Group;
};

/** Autogenerated input type of AddPaymentMethodMutation */
export type AddPaymentMethodMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	token: Scalars["String"];
	default_source?: InputMaybe<Scalars["Boolean"]>;
};

/** Autogenerated return type of AddPaymentMethodMutation. */
export type AddPaymentMethodMutationPayload = {
	__typename?: "AddPaymentMethodMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	customer: Customer;
};

export type Address = {
	__typename?: "Address";
	city?: Maybe<Scalars["String"]>;
	country?: Maybe<Scalars["String"]>;
	line1?: Maybe<Scalars["String"]>;
	line2?: Maybe<Scalars["String"]>;
	postal_code?: Maybe<Scalars["String"]>;
	state?: Maybe<Scalars["String"]>;
};

/** Available filters for the given advanced Search */
export type AdvancedFilterResult = {
	__typename?: "AdvancedFilterResult";
	fields?: Maybe<Array<FieldsEnum>>;
	order?: Maybe<Array<SortOrderEnum>>;
	what?: Maybe<Array<WhatEnum>>;
	where?: Maybe<Array<WhereEnum>>;
};

/** Result for the advanced Search */
export type AdvancedResult = {
	__typename?: "AdvancedResult";
	filters?: Maybe<AdvancedFilterResult>;
	results?: Maybe<Array<Maybe<SsearchResult>>>;
	total: Scalars["Int"];
};

/** Autogenerated input type of ApplyCouponToSubscriptionMutation */
export type ApplyCouponToSubscriptionMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	coupon_code: Scalars["String"];
};

/** Autogenerated return type of ApplyCouponToSubscriptionMutation. */
export type ApplyCouponToSubscriptionMutationPayload = {
	__typename?: "ApplyCouponToSubscriptionMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** An attachment block */
export type Attachment = Block &
	ConnectableInterface &
	Model & {
		__typename?: "Attachment";
		can?: Maybe<BlockCan>;
		channels?: Maybe<Array<Channel>>;
		channels_with_same_source?: Maybe<Array<Channel>>;
		/** @deprecated Channels do not have comments. Call this on Block. */
		comments?: Maybe<Array<Comment>>;
		/** Returns the outer channel if we are inside of one */
		connection?: Maybe<Connection>;
		connections?: Maybe<Array<Maybe<Connection>>>;
		counts?: Maybe<BlockCounts>;
		created_at: Scalars["String"];
		current_user_channels?: Maybe<Array<Channel>>;
		description?: Maybe<Scalars["String"]>;
		file_content_type?: Maybe<Scalars["String"]>;
		file_extension?: Maybe<Scalars["String"]>;
		file_size?: Maybe<Scalars["String"]>;
		file_url?: Maybe<Scalars["String"]>;
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		image_updated_at?: Maybe<Scalars["String"]>;
		image_url?: Maybe<Scalars["String"]>;
		is_muted: Scalars["Boolean"];
		is_nsfw?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Avoid using if at all possible */
		kind?: Maybe<ConnectableKind>;
		klass?: Maybe<Scalars["String"]>;
		private_accessible_channels?: Maybe<Array<Channel>>;
		public_channels?: Maybe<Array<Channel>>;
		resized_image_url?: Maybe<Scalars["String"]>;
		source?: Maybe<ConnectableSource>;
		state: Scalars["String"];
		title: Scalars["String"];
		to_s: Scalars["String"];
		updated_at: Scalars["String"];
		user?: Maybe<User>;
		visibility?: Maybe<Scalars["String"]>;
	};

/** An attachment block */
export type AttachmentChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** An attachment block */
export type AttachmentChannels_With_Same_SourceArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** An attachment block */
export type AttachmentCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** An attachment block */
export type AttachmentCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** An attachment block */
export type AttachmentDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** An attachment block */
export type AttachmentFile_SizeArgs = {
	precision?: InputMaybe<Scalars["Int"]>;
};

/** An attachment block */
export type AttachmentHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** An attachment block */
export type AttachmentImage_Updated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** An attachment block */
export type AttachmentImage_UrlArgs = {
	size?: InputMaybe<ImageVersion>;
};

/** An attachment block */
export type AttachmentPrivate_Accessible_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** An attachment block */
export type AttachmentPublic_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** An attachment block */
export type AttachmentResized_Image_UrlArgs = {
	width?: InputMaybe<Scalars["Int"]>;
	height?: InputMaybe<Scalars["Int"]>;
	quality?: InputMaybe<Scalars["Int"]>;
	blur?: InputMaybe<Scalars["Int"]>;
	sharpen?: InputMaybe<Scalars["Int"]>;
	flatten?: InputMaybe<Scalars["Boolean"]>;
	fallback_format?: InputMaybe<ResizedImageFallbackFormat>;
	downloadable?: InputMaybe<Scalars["Boolean"]>;
};

/** An attachment block */
export type AttachmentTitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** An attachment block */
export type AttachmentTo_SArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** An attachment block */
export type AttachmentUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Providers for external authentication */
export enum AuthenticatedServiceProvider {
	Twitter = "TWITTER",
}

/** An authorized external service provider */
export type Authentication = Model & {
	__typename?: "Authentication";
	contacts?: Maybe<Array<User>>;
	created_at: Scalars["String"];
	id: Scalars["Int"];
	provider?: Maybe<Scalars["String"]>;
	uid?: Maybe<Scalars["String"]>;
	updated_at: Scalars["String"];
};

/** An authorized external service provider */
export type AuthenticationContactsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** An authorized external service provider */
export type AuthenticationCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** An authorized external service provider */
export type AuthenticationUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Avatar sizes */
export enum AvatarVersion {
	Small = "SMALL",
	Medium = "MEDIUM",
	Large = "LARGE",
	Uncropped = "UNCROPPED",
}

export enum BannerEnum {
	StronglyProposePremium = "STRONGLY_PROPOSE_PREMIUM",
	ProposePremium = "PROPOSE_PREMIUM",
	CreateChannel = "CREATE_CHANNEL",
	CreateConnections = "CREATE_CONNECTIONS",
	FollowAnything = "FOLLOW_ANYTHING",
	Confirm = "CONFIRM",
	Bookmarklet = "BOOKMARKLET",
	Invite = "INVITE",
	MonthlyPremiumReminder = "MONTHLY_PREMIUM_REMINDER",
	PremiumPlus = "PREMIUM_PLUS",
	PreviouslyPremium = "PREVIOUSLY_PREMIUM",
}

/** Possible connectables for a new connection */
export enum BaseConnectableTypeEnum {
	Block = "BLOCK",
	Channel = "CHANNEL",
}

/** Fields common to all Block types */
export type Block = {
	can?: Maybe<BlockCan>;
	channels_with_same_source?: Maybe<Array<Channel>>;
	comments?: Maybe<Array<Comment>>;
	counts?: Maybe<BlockCounts>;
	is_nsfw?: Maybe<Scalars["Boolean"]>;
	state?: Maybe<Scalars["String"]>;
};

/** Fields common to all Block types */
export type BlockChannels_With_Same_SourceArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** Fields common to all Block types */
export type BlockCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** The actions that the CurrentUser can perform on the Block */
export type BlockCan = {
	__typename?: "BlockCan";
	comment: Scalars["Boolean"];
	connect: Scalars["Boolean"];
	edit_thumbnail: Scalars["Boolean"];
	manage: Scalars["Boolean"];
	mute: Scalars["Boolean"];
	potentially_edit_thumbnail: Scalars["Boolean"];
	read: Scalars["Boolean"];
	remove_connection: Scalars["Boolean"];
};

/** The actions that the CurrentUser can perform on the Block */
export type BlockCanRemove_ConnectionArgs = {
	channel_id: Scalars["ID"];
};

export type BlockCounts = {
	__typename?: "BlockCounts";
	channels?: Maybe<Scalars["Int"]>;
	channels_by_current_user?: Maybe<Scalars["Int"]>;
	channels_with_same_source?: Maybe<Scalars["Int"]>;
	comments?: Maybe<Scalars["Int"]>;
	private_accessible_channels?: Maybe<Scalars["Int"]>;
	public_channels?: Maybe<Scalars["Int"]>;
};

/** Block types */
export enum BlockFilterEnum {
	All = "ALL",
	Image = "IMAGE",
	Embed = "EMBED",
	Text = "TEXT",
	Attachment = "ATTACHMENT",
	Link = "LINK",
}

/** Autogenerated input type of CancelChannelTransferMutation */
export type CancelChannelTransferMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of CancelChannelTransferMutation. */
export type CancelChannelTransferMutationPayload = {
	__typename?: "CancelChannelTransferMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of CancelPremiumSubscriptionMutation */
export type CancelPremiumSubscriptionMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of CancelPremiumSubscriptionMutation. */
export type CancelPremiumSubscriptionMutationPayload = {
	__typename?: "CancelPremiumSubscriptionMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** Autogenerated input type of CancelPremiumSubscriptionsMutation */
export type CancelPremiumSubscriptionsMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	user_ids: Array<InputMaybe<Scalars["ID"]>>;
};

/** Autogenerated return type of CancelPremiumSubscriptionsMutation. */
export type CancelPremiumSubscriptionsMutationPayload = {
	__typename?: "CancelPremiumSubscriptionsMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
	users: Array<User>;
};

/** A distinct URL with extra info extracted */
export type CanonicalLink = Model & {
	__typename?: "CanonicalLink";
	authors?: Maybe<Scalars["String"]>;
	content?: Maybe<Scalars["String"]>;
	created_at: Scalars["String"];
	description?: Maybe<Scalars["String"]>;
	id: Scalars["Int"];
	provider_name?: Maybe<Scalars["String"]>;
	provider_url?: Maybe<Scalars["String"]>;
	published_at?: Maybe<Scalars["String"]>;
	safe: Scalars["Boolean"];
	state?: Maybe<Scalars["String"]>;
	title?: Maybe<Scalars["String"]>;
	updated_at: Scalars["String"];
	url?: Maybe<Scalars["String"]>;
};

/** A distinct URL with extra info extracted */
export type CanonicalLinkCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A distinct URL with extra info extracted */
export type CanonicalLinkPublished_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A distinct URL with extra info extracted */
export type CanonicalLinkUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A single channel */
export type Channel = ConnectableInterface &
	Followable &
	Model &
	Mutable & {
		__typename?: "Channel";
		added_to_at?: Maybe<Scalars["String"]>;
		/** @deprecated Use `blokks` until this can be replaced with it */
		blocks?: Maybe<Array<Connectable>>;
		blokks: Array<Konnectable>;
		can: ChannelCan;
		channels?: Maybe<Array<Channel>>;
		/** @deprecated This only returns Users. Use `members` field instead */
		collaborators?: Maybe<Array<User>>;
		/** @deprecated Channels do not have comments. Call this on Block. */
		comments?: Maybe<Array<Comment>>;
		/** Returns a gzipped and base64 encoded JSON string of the unfiltered channel skeleton */
		compressed_skeleton: Scalars["String"];
		connected_to_channels: Array<Channel>;
		/** Returns the outer channel if we are inside of one */
		connection?: Maybe<Connection>;
		connections?: Maybe<Array<Maybe<Connection>>>;
		connectors: Array<User>;
		content_flag?: Maybe<Scalars["String"]>;
		contents?: Maybe<Array<Konnectable>>;
		counts: ChannelCounts;
		created_at: Scalars["String"];
		current_user_channels?: Maybe<Array<Channel>>;
		description?: Maybe<Scalars["String"]>;
		filter: Array<Konnectable>;
		followers?: Maybe<Array<User>>;
		href: Scalars["String"];
		id: Scalars["Int"];
		image_url?: Maybe<Scalars["String"]>;
		is_collaboration: Scalars["Boolean"];
		is_followed: Scalars["Boolean"];
		is_muted: Scalars["Boolean"];
		is_nsfw: Scalars["Boolean"];
		/** @deprecated Use `visibility` */
		is_open: Scalars["Boolean"];
		is_pending_transfer: Scalars["Boolean"];
		/** @deprecated Use `visibility` */
		is_published: Scalars["Boolean"];
		is_restricted: Scalars["Boolean"];
		/** @deprecated Avoid using if at all possible */
		kind?: Maybe<ConnectableKind>;
		klass?: Maybe<Scalars["String"]>;
		members: Array<Member>;
		memberships: Array<ChannelMembership>;
		owner: ChannelOwner;
		private_accessible_channels?: Maybe<Array<Channel>>;
		public_channels?: Maybe<Array<Channel>>;
		share?: Maybe<ChannelShare>;
		share_id?: Maybe<Scalars["String"]>;
		skeleton: Array<SkeletalConnectable>;
		slug: Scalars["String"];
		source?: Maybe<ConnectableSource>;
		state: Scalars["String"];
		title: Scalars["String"];
		to_s: Scalars["String"];
		transfer_request?: Maybe<ChannelTransferRequest>;
		type: Scalars["String"];
		types: Array<ConnectableTypeEnum>;
		updated_at: Scalars["String"];
		user?: Maybe<User>;
		visibility: Scalars["String"];
	};

/** A single channel */
export type ChannelAdded_To_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A single channel */
export type ChannelBlocksArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<Sorts>;
	direction?: InputMaybe<SortDirection>;
	type?: InputMaybe<ConnectableTypeEnum>;
	user_id?: InputMaybe<Scalars["ID"]>;
};

/** A single channel */
export type ChannelBlokksArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<Sorts>;
	direction?: InputMaybe<SortDirection>;
	type?: InputMaybe<ConnectableTypeEnum>;
	user_id?: InputMaybe<Scalars["ID"]>;
};

/** A single channel */
export type ChannelChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** A single channel */
export type ChannelCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** A single channel */
export type ChannelConnected_To_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A single channel */
export type ChannelConnectorsArgs = {
	q?: InputMaybe<Scalars["String"]>;
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A single channel */
export type ChannelContentsArgs = {
	connectables?: InputMaybe<Array<InputMaybe<ConnectableInput>>>;
};

/** A single channel */
export type ChannelCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A single channel */
export type ChannelDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A single channel */
export type ChannelFilterArgs = {
	q?: InputMaybe<Scalars["String"]>;
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A single channel */
export type ChannelFollowersArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A single channel */
export type ChannelHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** A single channel */
export type ChannelImage_UrlArgs = {
	size?: InputMaybe<ImageVersion>;
};

/** A single channel */
export type ChannelPrivate_Accessible_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A single channel */
export type ChannelPublic_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A single channel */
export type ChannelSkeletonArgs = {
	type?: InputMaybe<Array<BaseConnectableTypeEnum>>;
};

/** A single channel */
export type ChannelTitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A single channel */
export type ChannelTo_SArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A single channel */
export type ChannelUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** The actions that the CurrentUser can perform on the Channel */
export type ChannelCan = {
	__typename?: "ChannelCan";
	add_to: Scalars["Boolean"];
	add_to_as_premium: Scalars["Boolean"];
	connect: Scalars["Boolean"];
	destroy: Scalars["Boolean"];
	export: Scalars["Boolean"];
	follow: Scalars["Boolean"];
	manage: Scalars["Boolean"];
	manage_collaborators: Scalars["Boolean"];
	mute: Scalars["Boolean"];
	read: Scalars["Boolean"];
	remove_connection: Scalars["Boolean"];
	share: Scalars["Boolean"];
	transfer: Scalars["Boolean"];
	update: Scalars["Boolean"];
};

/** The actions that the CurrentUser can perform on the Channel */
export type ChannelCanRemove_ConnectionArgs = {
	channel_id: Scalars["ID"];
};

export type ChannelCounts = {
	__typename?: "ChannelCounts";
	blocks: Scalars["Int"];
	channels: Scalars["Int"];
	collaborators: Scalars["Int"];
	connected_to_channels: Scalars["Int"];
	contents: Scalars["Int"];
	followers: Scalars["Int"];
};

export type ChannelCountsContentsArgs = {
	type?: InputMaybe<ConnectableTypeEnum>;
	user_id?: InputMaybe<Scalars["ID"]>;
};

export type ChannelMemberInput = {
	id: Scalars["ID"];
	type?: InputMaybe<MemberTypes>;
};

/** A membership defining the relationship between Channels and Members (Users or Groups) */
export type ChannelMembership = Model & {
	__typename?: "ChannelMembership";
	can?: Maybe<ChannelMembershipCan>;
	created_at: Scalars["String"];
	id: Scalars["Int"];
	member?: Maybe<Member>;
	updated_at: Scalars["String"];
};

/** A membership defining the relationship between Channels and Members (Users or Groups) */
export type ChannelMembershipCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A membership defining the relationship between Channels and Members (Users or Groups) */
export type ChannelMembershipUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** The actions that the CurrentUser can perform on the ChannelMembership */
export type ChannelMembershipCan = {
	__typename?: "ChannelMembershipCan";
	manage: Scalars["Boolean"];
};

export type ChannelOwner = Group | User;

export enum ChannelOwnerTypeEnum {
	User = "USER",
	Group = "GROUP",
}

/** Properties needed to share channels externally */
export type ChannelShare = {
	__typename?: "ChannelShare";
	facebook_url?: Maybe<Scalars["String"]>;
	twitter_url?: Maybe<Scalars["String"]>;
	url?: Maybe<Scalars["String"]>;
};

/** A request to transfer the ownership of a channel to a new user */
export type ChannelTransferRequest = Model & {
	__typename?: "ChannelTransferRequest";
	channel: Channel;
	created_at: Scalars["String"];
	id: Scalars["Int"];
	is_recipient_member: Scalars["Boolean"];
	/** @deprecated User => Owner: use `is_recipient_member` field */
	is_user_to_member?: Maybe<Scalars["Boolean"]>;
	recipient: ChannelOwner;
	sender: ChannelOwner;
	updated_at: Scalars["String"];
	/** @deprecated User => Owner: use `sender` field */
	user_from?: Maybe<User>;
	/** @deprecated User => Owner: use recipient field */
	user_to?: Maybe<User>;
};

/** A request to transfer the ownership of a channel to a new user */
export type ChannelTransferRequestCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A request to transfer the ownership of a channel to a new user */
export type ChannelTransferRequestUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Privacy states for a channel */
export enum ChannelVisibility {
	Public = "PUBLIC",
	Closed = "CLOSED",
	Private = "PRIVATE",
}

/** Ways to sort channels */
export enum ChannelsSort {
	AddedToAt = "ADDED_TO_AT",
	UpdatedAt = "UPDATED_AT",
	CreatedAt = "CREATED_AT",
	Title = "TITLE",
}

/** Autogenerated input type of ClearNotificationsMutation */
export type ClearNotificationsMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	confirm: Scalars["Boolean"];
};

/** Autogenerated return type of ClearNotificationsMutation. */
export type ClearNotificationsMutationPayload = {
	__typename?: "ClearNotificationsMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** A single comment */
export type Comment = Model & {
	__typename?: "Comment";
	body?: Maybe<Scalars["String"]>;
	can?: Maybe<CommentCan>;
	commentable: Commentable;
	created_at: Scalars["String"];
	href?: Maybe<Scalars["String"]>;
	id: Scalars["Int"];
	updated_at: Scalars["String"];
	user?: Maybe<User>;
};

/** A single comment */
export type CommentBodyArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A single comment */
export type CommentCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A single comment */
export type CommentHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** A single comment */
export type CommentUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type CommentCan = {
	__typename?: "CommentCan";
	destroy: Scalars["Boolean"];
	manage: Scalars["Boolean"];
};

/** Union of objects that can be commented on */
export type Commentable =
	| Attachment
	| Embed
	| Image
	| Link
	| PendingBlock
	| Text;

/** Autogenerated input type of ConfirmAccountMutation */
export type ConfirmAccountMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	token: Scalars["String"];
};

/** Autogenerated return type of ConfirmAccountMutation. */
export type ConfirmAccountMutationPayload = {
	__typename?: "ConfirmAccountMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	status: ConfirmedStatus;
	user: Me;
};

/** State of the logged in account */
export enum ConfirmedStatus {
	Confirmed = "CONFIRMED",
	AlreadyConfirmed = "ALREADY_CONFIRMED",
	Error = "ERROR",
}

/** A block or a channel */
export type Connectable = ConnectableInterface &
	Model &
	Mutable & {
		__typename?: "Connectable";
		/** @deprecated Use specific type cans */
		can?: Maybe<ConnectableCan>;
		channels?: Maybe<Array<Channel>>;
		/** @deprecated Channels do not have comments. Call this on Block. */
		comments?: Maybe<Array<Comment>>;
		/** Returns the outer channel if we are inside of one */
		connection?: Maybe<Connection>;
		connections?: Maybe<Array<Maybe<Connection>>>;
		created_at: Scalars["String"];
		current_user_channels?: Maybe<Array<Channel>>;
		description?: Maybe<Scalars["String"]>;
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		is_muted: Scalars["Boolean"];
		/** @deprecated Avoid using if at all possible */
		kind?: Maybe<ConnectableKind>;
		klass?: Maybe<Scalars["String"]>;
		private_accessible_channels?: Maybe<Array<Channel>>;
		public_channels?: Maybe<Array<Channel>>;
		source?: Maybe<ConnectableSource>;
		state: Scalars["String"];
		title: Scalars["String"];
		to_s: Scalars["String"];
		updated_at: Scalars["String"];
		user?: Maybe<User>;
		visibility?: Maybe<Scalars["String"]>;
	};

/** A block or a channel */
export type ConnectableChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** A block or a channel */
export type ConnectableCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** A block or a channel */
export type ConnectableCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A block or a channel */
export type ConnectableDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A block or a channel */
export type ConnectableHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** A block or a channel */
export type ConnectablePrivate_Accessible_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A block or a channel */
export type ConnectablePublic_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A block or a channel */
export type ConnectableTitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A block or a channel */
export type ConnectableTo_SArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A block or a channel */
export type ConnectableUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** The actions that the CurrentUser can perform on the Connectable */
export type ConnectableCan = {
	__typename?: "ConnectableCan";
	manage: Scalars["Boolean"];
	read: Scalars["Boolean"];
};

export type ConnectableInput = {
	id: Scalars["ID"];
	type: BaseConnectableTypeEnum;
};

/** Fields common to models that can be connected */
export type ConnectableInterface = {
	channels?: Maybe<Array<Channel>>;
	/** @deprecated Channels do not have comments. Call this on Block. */
	comments?: Maybe<Array<Comment>>;
	/** Returns the outer channel if we are inside of one */
	connection?: Maybe<Connection>;
	connections?: Maybe<Array<Maybe<Connection>>>;
	current_user_channels?: Maybe<Array<Channel>>;
	description?: Maybe<Scalars["String"]>;
	href?: Maybe<Scalars["String"]>;
	is_muted: Scalars["Boolean"];
	/** @deprecated Avoid using if at all possible */
	kind?: Maybe<ConnectableKind>;
	klass?: Maybe<Scalars["String"]>;
	private_accessible_channels?: Maybe<Array<Channel>>;
	public_channels?: Maybe<Array<Channel>>;
	source?: Maybe<ConnectableSource>;
	state: Scalars["String"];
	title: Scalars["String"];
	to_s: Scalars["String"];
	user?: Maybe<User>;
	visibility?: Maybe<Scalars["String"]>;
};

/** Fields common to models that can be connected */
export type ConnectableInterfaceChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** Fields common to models that can be connected */
export type ConnectableInterfaceCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** Fields common to models that can be connected */
export type ConnectableInterfaceDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** Fields common to models that can be connected */
export type ConnectableInterfaceHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** Fields common to models that can be connected */
export type ConnectableInterfacePrivate_Accessible_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** Fields common to models that can be connected */
export type ConnectableInterfacePublic_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** Fields common to models that can be connected */
export type ConnectableInterfaceTitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** Fields common to models that can be connected */
export type ConnectableInterfaceTo_SArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** Connectable attributes specific to its class */
export type ConnectableKind =
	| Attachment
	| Channel
	| Embed
	| Image
	| Link
	| PendingBlock
	| Text;

export type ConnectableSource = {
	__typename?: "ConnectableSource";
	provider_name?: Maybe<Scalars["String"]>;
	provider_url?: Maybe<Scalars["String"]>;
	title?: Maybe<Scalars["String"]>;
	url?: Maybe<Scalars["String"]>;
};

/** Connectable types */
export enum ConnectableTypeEnum {
	Image = "IMAGE",
	Embed = "EMBED",
	Text = "TEXT",
	Channel = "CHANNEL",
	Attachment = "ATTACHMENT",
	Link = "LINK",
	Block = "BLOCK",
}

/** A connection */
export type Connection = Model & {
	__typename?: "Connection";
	can?: Maybe<ConnectionCan>;
	channel: Channel;
	connectable: Connectable;
	created_at: Scalars["String"];
	id: Scalars["Int"];
	position: Scalars["Int"];
	selected: Scalars["Boolean"];
	updated_at: Scalars["String"];
	user?: Maybe<User>;
};

/** A connection */
export type ConnectionCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A connection */
export type ConnectionUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** The actions that the CurrentUser can perform on the Connection */
export type ConnectionCan = {
	__typename?: "ConnectionCan";
	create: Scalars["Boolean"];
	destroy: Scalars["Boolean"];
	manage: Scalars["Boolean"];
};

/** Available content flag states for channels */
export enum ContentFlag {
	Nsfw = "NSFW",
	Safe = "SAFE",
}

export type Coupon = {
	__typename?: "Coupon";
	amount_off?: Maybe<Scalars["Int"]>;
	code?: Maybe<Scalars["String"]>;
	created_at?: Maybe<Scalars["String"]>;
	currency?: Maybe<Scalars["String"]>;
	description?: Maybe<Scalars["String"]>;
	duration?: Maybe<Scalars["String"]>;
	duration_in_months?: Maybe<Scalars["String"]>;
	id?: Maybe<Scalars["String"]>;
	is_valid?: Maybe<Scalars["Boolean"]>;
	percent_off?: Maybe<Scalars["Int"]>;
	redeem_by?: Maybe<Scalars["String"]>;
};

export type CouponCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type CouponRedeem_ByArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated input type of CreateAuthenticatedServiceMutation */
export type CreateAuthenticatedServiceMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	provider?: InputMaybe<AuthenticatedServiceProvider>;
	uid: Scalars["String"];
	avatar_url?: InputMaybe<Scalars["String"]>;
	token: Scalars["String"];
	secret: Scalars["String"];
};

/** Autogenerated return type of CreateAuthenticatedServiceMutation. */
export type CreateAuthenticatedServiceMutationPayload = {
	__typename?: "CreateAuthenticatedServiceMutationPayload";
	authenticated_service: Authentication;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of CreateBlockMutation */
export type CreateBlockMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	channel_ids: Array<InputMaybe<Scalars["ID"]>>;
	source_url?: InputMaybe<Scalars["String"]>;
	content?: InputMaybe<Scalars["String"]>;
	value?: InputMaybe<Scalars["String"]>;
	title?: InputMaybe<Scalars["String"]>;
	description?: InputMaybe<Scalars["String"]>;
	original_source_url?: InputMaybe<Scalars["String"]>;
	original_source_title?: InputMaybe<Scalars["String"]>;
	alt_text?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateBlockMutation. */
export type CreateBlockMutationPayload = {
	__typename?: "CreateBlockMutationPayload";
	block: Connectable;
	blokk: Konnectable;
	channels: Array<Channel>;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of CreateChannel */
export type CreateChannelInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	title: Scalars["String"];
	visibility?: InputMaybe<ChannelVisibility>;
	description?: InputMaybe<Scalars["String"]>;
	group_id?: InputMaybe<Scalars["ID"]>;
};

/** Autogenerated return type of CreateChannel. */
export type CreateChannelPayload = {
	__typename?: "CreateChannelPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of CreateCommentMutation */
export type CreateCommentMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	block_id: Scalars["ID"];
	body: Scalars["String"];
};

/** Autogenerated return type of CreateCommentMutation. */
export type CreateCommentMutationPayload = {
	__typename?: "CreateCommentMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	comment: Comment;
};

/** Autogenerated input type of CreateConnectionMutation */
export type CreateConnectionMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	connectable_id: Scalars["ID"];
	connectable_type: BaseConnectableTypeEnum;
	channel_ids?: InputMaybe<Array<InputMaybe<Scalars["ID"]>>>;
};

/** Autogenerated return type of CreateConnectionMutation. */
export type CreateConnectionMutationPayload = {
	__typename?: "CreateConnectionMutationPayload";
	channels: Array<Channel>;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	connectable: Connectable;
	connections: Array<Connection>;
	konnectable: Konnectable;
};

/** Autogenerated return type of CreateConnectionMutation. */
export type CreateConnectionMutationPayloadConnectionsArgs = {
	after?: InputMaybe<Scalars["String"]>;
	before?: InputMaybe<Scalars["String"]>;
	first?: InputMaybe<Scalars["Int"]>;
	last?: InputMaybe<Scalars["Int"]>;
};

/** Autogenerated input type of CreateCustomerPortalSessionMutation */
export type CreateCustomerPortalSessionMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateCustomerPortalSessionMutation. */
export type CreateCustomerPortalSessionMutationPayload = {
	__typename?: "CreateCustomerPortalSessionMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	url: Scalars["String"];
};

/** Autogenerated input type of CreateGroupInviteMutation */
export type CreateGroupInviteMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	group_id?: InputMaybe<Scalars["ID"]>;
};

/** Autogenerated return type of CreateGroupInviteMutation. */
export type CreateGroupInviteMutationPayload = {
	__typename?: "CreateGroupInviteMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	group: Group;
};

/** Autogenerated input type of CreateGroupMutation */
export type CreateGroupMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	name: Scalars["String"];
	description?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of CreateGroupMutation. */
export type CreateGroupMutationPayload = {
	__typename?: "CreateGroupMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	group: Group;
};

/** Autogenerated input type of CreateUserMessageChannelMutation */
export type CreateUserMessageChannelMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of CreateUserMessageChannelMutation. */
export type CreateUserMessageChannelMutationPayload = {
	__typename?: "CreateUserMessageChannelMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

export type CreditCard = {
	__typename?: "CreditCard";
	brand?: Maybe<Scalars["String"]>;
	exp_month?: Maybe<Scalars["String"]>;
	exp_year?: Maybe<Scalars["String"]>;
	id?: Maybe<Scalars["String"]>;
	last4?: Maybe<Scalars["String"]>;
};

/** Custom badge sizes */
export enum CustomBadgeVersion {
	Small = "SMALL",
	Large = "LARGE",
}

/** Your account customer data */
export type Customer = Model & {
	__typename?: "Customer";
	address?: Maybe<Address>;
	can_select_lifetime: Scalars["Boolean"];
	created_at: Scalars["String"];
	/** @deprecated Use `payment_methods` instead */
	credit_cards?: Maybe<Array<CreditCard>>;
	current_period_end_at?: Maybe<Scalars["String"]>;
	current_period_start_at?: Maybe<Scalars["String"]>;
	/** @deprecated Use `default_payment_method` instead */
	default_credit_card?: Maybe<CreditCard>;
	default_payment_method?: Maybe<PaymentMethod>;
	external_id?: Maybe<Scalars["String"]>;
	id: Scalars["Int"];
	is_beneficiary: Scalars["Boolean"];
	is_canceled: Scalars["Boolean"];
	is_delinquent: Scalars["Boolean"];
	is_lifetime: Scalars["Boolean"];
	is_patron: Scalars["Boolean"];
	is_premium: Scalars["Boolean"];
	is_previously_premium: Scalars["Boolean"];
	patron?: Maybe<User>;
	payment_methods?: Maybe<Array<PaymentMethod>>;
	plan?: Maybe<Plan>;
	plan_id?: Maybe<Scalars["String"]>;
	status?: Maybe<Scalars["String"]>;
	subscription?: Maybe<PremiumSubscription>;
	upcoming_invoice?: Maybe<Invoice>;
	updated_at: Scalars["String"];
};

/** Your account customer data */
export type CustomerCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Your account customer data */
export type CustomerCurrent_Period_End_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Your account customer data */
export type CustomerCurrent_Period_Start_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Your account customer data */
export type CustomerUpcoming_InvoiceArgs = {
	plan_id?: InputMaybe<SupportedPlanEnum>;
	coupon_code?: InputMaybe<Scalars["String"]>;
	include_tax?: InputMaybe<Scalars["Boolean"]>;
};

/** Your account customer data */
export type CustomerUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export enum CustomerStatuses {
	Active = "ACTIVE",
	Canceled = "CANCELED",
	Inactive = "INACTIVE",
}

/** A single deed */
export type Deed = Model & {
	__typename?: "Deed";
	action: Scalars["String"];
	bulletin_id: Scalars["ID"];
	connector?: Maybe<Scalars["String"]>;
	created_at: Scalars["String"];
	id: Scalars["Int"];
	is_private: Scalars["Boolean"];
	is_read: Scalars["Boolean"];
	item: DeedKind;
	item_title: Scalars["String"];
	owner: DeedOwner;
	parent?: Maybe<DeedKind>;
	target?: Maybe<DeedKind>;
	updated_at: Scalars["String"];
	user?: Maybe<User>;
};

/** A single deed */
export type DeedCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A single deed */
export type DeedItem_TitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A single deed */
export type DeedUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A group of deeds */
export type DeedGroup = {
	__typename?: "DeedGroup";
	action: Scalars["String"];
	are_all_read: Scalars["Boolean"];
	connector?: Maybe<Scalars["String"]>;
	created_at?: Maybe<Scalars["String"]>;
	deeds?: Maybe<Array<Deed>>;
	ids: Array<Scalars["ID"]>;
	is_private: Scalars["Boolean"];
	is_single: Scalars["Boolean"];
	item?: Maybe<DeedKind>;
	item_phrase: Scalars["String"];
	/** @deprecated Use `objects` */
	items?: Maybe<Array<DeedKind>>;
	key: Scalars["String"];
	length: Scalars["Int"];
	/** @deprecated Use `item` */
	object?: Maybe<DeedKind>;
	/** @deprecated Use `item_phrase` */
	object_phrase: Scalars["String"];
	objects?: Maybe<Array<DeedKkind>>;
	owner: DeedOwner;
	target?: Maybe<DeedKind>;
	target_phrase: Scalars["String"];
	user?: Maybe<User>;
	/** @deprecated Use `action` */
	verb?: Maybe<Scalars["String"]>;
};

/** A group of deeds */
export type DeedGroupCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A group of deeds */
export type DeedGroupItem_PhraseArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A group of deeds */
export type DeedGroupObject_PhraseArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A group of deeds */
export type DeedGroupTarget_PhraseArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** Deed item, target, or parent */
export type DeedKind =
	| Attachment
	| Channel
	| Comment
	| Connectable
	| Embed
	| Group
	| Image
	| Link
	| Text
	| User;

/** Deed item, target, or parent */
export type DeedKkind =
	| Attachment
	| Channel
	| Comment
	| Embed
	| Group
	| Image
	| Link
	| Text
	| User;

export type DeedOwner = Group | User;

/** Autogenerated input type of DeleteAuthenticatedServiceMutation */
export type DeleteAuthenticatedServiceMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of DeleteAuthenticatedServiceMutation. */
export type DeleteAuthenticatedServiceMutationPayload = {
	__typename?: "DeleteAuthenticatedServiceMutationPayload";
	authenticated_service: Authentication;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DeleteChannelMutation */
export type DeleteChannelMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of DeleteChannelMutation. */
export type DeleteChannelMutationPayload = {
	__typename?: "DeleteChannelMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
	status: Scalars["String"];
};

/** Autogenerated input type of DeleteCommentMutation */
export type DeleteCommentMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of DeleteCommentMutation. */
export type DeleteCommentMutationPayload = {
	__typename?: "DeleteCommentMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	commentable: Commentable;
	status: Scalars["String"];
};

/** Autogenerated input type of DeleteConnectionMutation */
export type DeleteConnectionMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of DeleteConnectionMutation. */
export type DeleteConnectionMutationPayload = {
	__typename?: "DeleteConnectionMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	status: Scalars["String"];
};

/** Autogenerated input type of DeleteGroupInviteMutation */
export type DeleteGroupInviteMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	group_id: Scalars["ID"];
};

/** Autogenerated return type of DeleteGroupInviteMutation. */
export type DeleteGroupInviteMutationPayload = {
	__typename?: "DeleteGroupInviteMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	group: Group;
};

/** Autogenerated input type of DeleteGroupMutation */
export type DeleteGroupMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of DeleteGroupMutation. */
export type DeleteGroupMutationPayload = {
	__typename?: "DeleteGroupMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	status: Scalars["String"];
};

/** Dimensions for an image block */
export type Dimensions = {
	__typename?: "Dimensions";
	height?: Maybe<Scalars["Int"]>;
	width?: Maybe<Scalars["Int"]>;
};

export type Discount = {
	__typename?: "Discount";
	coupon?: Maybe<Coupon>;
	id?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of DismissBannerMutation */
export type DismissBannerMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	banner: BannerEnum;
};

/** Autogenerated return type of DismissBannerMutation. */
export type DismissBannerMutationPayload = {
	__typename?: "DismissBannerMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** Autogenerated input type of DowngradeToLifetimeMutation */
export type DowngradeToLifetimeMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of DowngradeToLifetimeMutation. */
export type DowngradeToLifetimeMutationPayload = {
	__typename?: "DowngradeToLifetimeMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** An embed block */
export type Embed = Block &
	ConnectableInterface &
	Model & {
		__typename?: "Embed";
		can?: Maybe<BlockCan>;
		channels?: Maybe<Array<Channel>>;
		channels_with_same_source?: Maybe<Array<Channel>>;
		/** @deprecated Channels do not have comments. Call this on Block. */
		comments?: Maybe<Array<Comment>>;
		/** Returns the outer channel if we are inside of one */
		connection?: Maybe<Connection>;
		connections?: Maybe<Array<Maybe<Connection>>>;
		counts?: Maybe<BlockCounts>;
		created_at: Scalars["String"];
		current_user_channels?: Maybe<Array<Channel>>;
		description?: Maybe<Scalars["String"]>;
		embed_height?: Maybe<Scalars["Int"]>;
		embed_html?: Maybe<Scalars["String"]>;
		embed_width?: Maybe<Scalars["Int"]>;
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		image_updated_at?: Maybe<Scalars["String"]>;
		image_url?: Maybe<Scalars["String"]>;
		is_muted: Scalars["Boolean"];
		is_nsfw?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Avoid using if at all possible */
		kind?: Maybe<ConnectableKind>;
		klass?: Maybe<Scalars["String"]>;
		private_accessible_channels?: Maybe<Array<Channel>>;
		public_channels?: Maybe<Array<Channel>>;
		resized_image_url?: Maybe<Scalars["String"]>;
		source?: Maybe<ConnectableSource>;
		source_url?: Maybe<Scalars["String"]>;
		state: Scalars["String"];
		title: Scalars["String"];
		to_s: Scalars["String"];
		updated_at: Scalars["String"];
		user?: Maybe<User>;
		visibility?: Maybe<Scalars["String"]>;
	};

/** An embed block */
export type EmbedChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** An embed block */
export type EmbedChannels_With_Same_SourceArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** An embed block */
export type EmbedCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** An embed block */
export type EmbedCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** An embed block */
export type EmbedDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** An embed block */
export type EmbedHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** An embed block */
export type EmbedImage_Updated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** An embed block */
export type EmbedImage_UrlArgs = {
	size?: InputMaybe<ImageVersion>;
};

/** An embed block */
export type EmbedPrivate_Accessible_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** An embed block */
export type EmbedPublic_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** An embed block */
export type EmbedResized_Image_UrlArgs = {
	width?: InputMaybe<Scalars["Int"]>;
	height?: InputMaybe<Scalars["Int"]>;
	quality?: InputMaybe<Scalars["Int"]>;
	blur?: InputMaybe<Scalars["Int"]>;
	sharpen?: InputMaybe<Scalars["Int"]>;
	flatten?: InputMaybe<Scalars["Boolean"]>;
	fallback_format?: InputMaybe<ResizedImageFallbackFormat>;
	downloadable?: InputMaybe<Scalars["Boolean"]>;
};

/** An embed block */
export type EmbedTitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** An embed block */
export type EmbedTo_SArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** An embed block */
export type EmbedUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated input type of ExportChannelMutation */
export type ExportChannelMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	format: ExportFormats;
};

/** Autogenerated return type of ExportChannelMutation. */
export type ExportChannelMutationPayload = {
	__typename?: "ExportChannelMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	status: Scalars["String"];
};

export enum ExportFormats {
	Pdf = "PDF",
	Html = "HTML",
	Zip = "ZIP",
}

/** defines search file types/extensions */
export enum ExtensionsEnum {
	Aac = "AAC",
	Ai = "AI",
	Aiff = "AIFF",
	Avi = "AVI",
	Bmp = "BMP",
	Csv = "CSV",
	Doc = "DOC",
	Docx = "DOCX",
	Eps = "EPS",
	Epub = "EPUB",
	Fla = "FLA",
	Gif = "GIF",
	H264 = "H264",
	Ind = "IND",
	Indd = "INDD",
	Jpeg = "JPEG",
	Jpg = "JPG",
	Key = "KEY",
	Kml = "KML",
	Kmz = "KMZ",
	Latex = "LATEX",
	M4A = "M4A",
	Ma = "MA",
	Mb = "MB",
	Mid = "MID",
	Midi = "MIDI",
	Mov = "MOV",
	Mp3 = "MP3",
	Mp4 = "MP4",
	Mp4V = "MP4V",
	Mpeg = "MPEG",
	Mpg = "MPG",
	Mpg4 = "MPG4",
	Numbers = "NUMBERS",
	Oga = "OGA",
	Ogg = "OGG",
	Ogv = "OGV",
	Otf = "OTF",
	Pages = "PAGES",
	Pdf = "PDF",
	Pgp = "PGP",
	Png = "PNG",
	Ppt = "PPT",
	Pptx = "PPTX",
	Psd = "PSD",
	Svg = "SVG",
	Swa = "SWA",
	Swf = "SWF",
	Tex = "TEX",
	Texi = "TEXI",
	Texinfo = "TEXINFO",
	Tfm = "TFM",
	Tif = "TIF",
	Tiff = "TIFF",
	Torrent = "TORRENT",
	Ttc = "TTC",
	Ttf = "TTF",
	Txt = "TXT",
	Wav = "WAV",
	Webm = "WEBM",
	Webp = "WEBP",
	Wma = "WMA",
	Xls = "XLS",
	Xlsx = "XLSX",
	Xlt = "XLT",
}

/** A feed */
export type Feed = {
	__typename?: "Feed";
	deeds: Array<Deed>;
	groups: Array<DeedGroup>;
	total: Scalars["Int"];
};

export type Fields = {
	facets?: InputMaybe<Array<FieldsEnum>>;
	op?: InputMaybe<OperationEnum>;
};

/** defines search fields */
export enum FieldsEnum {
	All = "ALL",
	Name = "NAME",
	Description = "DESCRIPTION",
	Content = "CONTENT",
	Domain = "DOMAIN",
	Url = "URL",
}

/** Reason for flagging a content */
export enum FlagCategoryEnum {
	Nsfw = "NSFW",
	Spam = "SPAM",
	Offensive = "OFFENSIVE",
}

/** Autogenerated input type of FlagContentMutation */
export type FlagContentMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	type: BaseConnectableTypeEnum;
	category: FlagCategoryEnum;
};

/** Autogenerated return type of FlagContentMutation. */
export type FlagContentMutationPayload = {
	__typename?: "FlagContentMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	status: Scalars["String"];
};

/** Autogenerated input type of FollowMutation */
export type FollowMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	type: FollowableTypeEnum;
};

/** Autogenerated return type of FollowMutation. */
export type FollowMutationPayload = {
	__typename?: "FollowMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	followable: FollowableType;
};

/** Fields common to models that can be followed */
export type Followable = {
	followers?: Maybe<Array<User>>;
	is_followed: Scalars["Boolean"];
	is_restricted: Scalars["Boolean"];
};

/** Fields common to models that can be followed */
export type FollowableFollowersArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** Followable object */
export type FollowableType = Channel | Group | User;

/** Types of followable objects */
export enum FollowableTypeEnum {
	User = "USER",
	Channel = "CHANNEL",
	Group = "GROUP",
}

/** Ways to filter following */
export enum FollowingTypeEnum {
	All = "ALL",
	User = "USER",
	Channel = "CHANNEL",
	Group = "GROUP",
}

/** Ways to format a markdown field */
export enum Format {
	Html = "HTML",
	Markdown = "MARKDOWN",
}

/** A Group of Users */
export type Group = Followable &
	Model & {
		__typename?: "Group";
		avatar?: Maybe<Scalars["String"]>;
		can?: Maybe<GroupCan>;
		channels?: Maybe<Array<Channel>>;
		/** Special channel field that eager loads all the owner and does not do pagination */
		channels_index?: Maybe<Array<IndexedChannels>>;
		counts?: Maybe<GroupCounts>;
		created_at: Scalars["String"];
		description?: Maybe<Scalars["String"]>;
		feed?: Maybe<Feed>;
		followers?: Maybe<Array<User>>;
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		initials: Scalars["String"];
		invite?: Maybe<GroupInviteType>;
		is_current_user_a_member: Scalars["Boolean"];
		is_current_user_the_owner: Scalars["Boolean"];
		is_followed: Scalars["Boolean"];
		/** Is *every* user in the group Premium? */
		is_premium?: Maybe<Scalars["Boolean"]>;
		is_restricted: Scalars["Boolean"];
		/** Are *any* users in the group upgradeable to Premium? */
		is_upgradeable?: Maybe<Scalars["Boolean"]>;
		manageable_user_ids?: Maybe<Array<Scalars["Int"]>>;
		memberships?: Maybe<Array<GroupMembership>>;
		name: Scalars["String"];
		slug: Scalars["String"];
		subscription?: Maybe<PremiumSubscription>;
		upcoming_invoice?: Maybe<Invoice>;
		updated_at: Scalars["String"];
		user: User;
		users?: Maybe<Array<User>>;
		visibility: Scalars["String"];
	};

/** A Group of Users */
export type GroupAvatarArgs = {
	size?: InputMaybe<AvatarVersion>;
};

/** A Group of Users */
export type GroupChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	q?: InputMaybe<Scalars["String"]>;
};

/** A Group of Users */
export type GroupChannels_IndexArgs = {
	type?: InputMaybe<IndexedChannelsTypes>;
};

/** A Group of Users */
export type GroupCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A Group of Users */
export type GroupDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A Group of Users */
export type GroupFeedArgs = {
	offset?: InputMaybe<Scalars["Int"]>;
	limit?: InputMaybe<Scalars["Int"]>;
	start?: InputMaybe<Scalars["String"]>;
	end?: InputMaybe<Scalars["String"]>;
};

/** A Group of Users */
export type GroupFollowersArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A Group of Users */
export type GroupHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** A Group of Users */
export type GroupIs_PremiumArgs = {
	include_owner?: InputMaybe<Scalars["Boolean"]>;
};

/** A Group of Users */
export type GroupIs_UpgradeableArgs = {
	include_owner?: InputMaybe<Scalars["Boolean"]>;
};

/** A Group of Users */
export type GroupUpcoming_InvoiceArgs = {
	plan_id?: InputMaybe<SupportedPlanEnum>;
	coupon_code?: InputMaybe<Scalars["String"]>;
	quantity?: InputMaybe<Scalars["Int"]>;
};

/** A Group of Users */
export type GroupUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** The actions that the CurrentUser can perform on the Group */
export type GroupCan = {
	__typename?: "GroupCan";
	add_to: Scalars["Boolean"];
	destroy: Scalars["Boolean"];
	follow: Scalars["Boolean"];
	manage: Scalars["Boolean"];
	manage_users: Scalars["Boolean"];
	update: Scalars["Boolean"];
};

export type GroupCounts = {
	__typename?: "GroupCounts";
	channels?: Maybe<Scalars["Int"]>;
	followers: Scalars["Int"];
	users?: Maybe<Scalars["Int"]>;
};

/** An invitation to a group */
export type GroupInviteType = Model & {
	__typename?: "GroupInviteType";
	code?: Maybe<Scalars["String"]>;
	created_at: Scalars["String"];
	group?: Maybe<Group>;
	href?: Maybe<Scalars["String"]>;
	id: Scalars["Int"];
	updated_at: Scalars["String"];
};

/** An invitation to a group */
export type GroupInviteTypeCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** An invitation to a group */
export type GroupInviteTypeHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** An invitation to a group */
export type GroupInviteTypeUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A membership defining the relationship between Groups and Users */
export type GroupMembership = Model & {
	__typename?: "GroupMembership";
	can?: Maybe<GroupMembershipCan>;
	created_at: Scalars["String"];
	id: Scalars["Int"];
	updated_at: Scalars["String"];
	user?: Maybe<User>;
};

/** A membership defining the relationship between Groups and Users */
export type GroupMembershipCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A membership defining the relationship between Groups and Users */
export type GroupMembershipUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** The actions that the CurrentUser can perform on the GroupMembership */
export type GroupMembershipCan = {
	__typename?: "GroupMembershipCan";
	manage: Scalars["Boolean"];
};

/** A preview of a group */
export type GroupPreview = Model & {
	__typename?: "GroupPreview";
	avatar?: Maybe<Scalars["String"]>;
	counts?: Maybe<GroupCounts>;
	created_at: Scalars["String"];
	description?: Maybe<Scalars["String"]>;
	href?: Maybe<Scalars["String"]>;
	id: Scalars["Int"];
	initials?: Maybe<Scalars["String"]>;
	name?: Maybe<Scalars["String"]>;
	slug?: Maybe<Scalars["String"]>;
	updated_at: Scalars["String"];
	user?: Maybe<User>;
	users?: Maybe<Array<User>>;
	visibility?: Maybe<Scalars["String"]>;
};

/** A preview of a group */
export type GroupPreviewAvatarArgs = {
	size?: InputMaybe<AvatarVersion>;
};

/** A preview of a group */
export type GroupPreviewCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A preview of a group */
export type GroupPreviewDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A preview of a group */
export type GroupPreviewHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** A preview of a group */
export type GroupPreviewUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Relationship to group */
export enum GroupType {
	All = "ALL",
	Owner = "OWNER",
	Member = "MEMBER",
}

export type Identifiable = Group | User;

/** An object which exposes and names Users and Groups */
export type Identity = {
	__typename?: "Identity";
	identifiable: Identifiable;
	name: Scalars["String"];
	slug: Scalars["String"];
};

/** An image block */
export type Image = Block &
	ConnectableInterface &
	Model & {
		__typename?: "Image";
		alt_text?: Maybe<Scalars["String"]>;
		can?: Maybe<BlockCan>;
		channels?: Maybe<Array<Channel>>;
		channels_with_same_source?: Maybe<Array<Channel>>;
		/** @deprecated Channels do not have comments. Call this on Block. */
		comments?: Maybe<Array<Comment>>;
		/** Returns the outer channel if we are inside of one */
		connection?: Maybe<Connection>;
		connections?: Maybe<Array<Maybe<Connection>>>;
		counts?: Maybe<BlockCounts>;
		created_at: Scalars["String"];
		current_user_channels?: Maybe<Array<Channel>>;
		description?: Maybe<Scalars["String"]>;
		/** URL to find the original image on various services */
		find_original_url?: Maybe<Scalars["String"]>;
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		image_url?: Maybe<Scalars["String"]>;
		is_muted: Scalars["Boolean"];
		is_nsfw?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Avoid using if at all possible */
		kind?: Maybe<ConnectableKind>;
		klass?: Maybe<Scalars["String"]>;
		original_dimensions?: Maybe<Dimensions>;
		private_accessible_channels?: Maybe<Array<Channel>>;
		public_channels?: Maybe<Array<Channel>>;
		resized_image_url?: Maybe<Scalars["String"]>;
		source?: Maybe<ConnectableSource>;
		state: Scalars["String"];
		title: Scalars["String"];
		to_s: Scalars["String"];
		updated_at: Scalars["String"];
		user?: Maybe<User>;
		visibility?: Maybe<Scalars["String"]>;
	};

/** An image block */
export type ImageChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** An image block */
export type ImageChannels_With_Same_SourceArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** An image block */
export type ImageCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** An image block */
export type ImageCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** An image block */
export type ImageDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** An image block */
export type ImageFind_Original_UrlArgs = {
	service?: InputMaybe<OriginalUrlServiceEnum>;
};

/** An image block */
export type ImageHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** An image block */
export type ImageImage_UrlArgs = {
	size?: InputMaybe<ImageVersion>;
};

/** An image block */
export type ImagePrivate_Accessible_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** An image block */
export type ImagePublic_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** An image block */
export type ImageResized_Image_UrlArgs = {
	width?: InputMaybe<Scalars["Int"]>;
	height?: InputMaybe<Scalars["Int"]>;
	quality?: InputMaybe<Scalars["Int"]>;
	blur?: InputMaybe<Scalars["Int"]>;
	sharpen?: InputMaybe<Scalars["Int"]>;
	flatten?: InputMaybe<Scalars["Boolean"]>;
	fallback_format?: InputMaybe<ResizedImageFallbackFormat>;
	downloadable?: InputMaybe<Scalars["Boolean"]>;
};

/** An image block */
export type ImageTitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** An image block */
export type ImageTo_SArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** An image block */
export type ImageUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Image sizes */
export enum ImageVersion {
	Thumb = "THUMB",
	Square = "SQUARE",
	Display = "DISPLAY",
	Large = "LARGE",
	Original = "ORIGINAL",
}

export type IndexedChannels = {
	__typename?: "IndexedChannels";
	channels: Array<Channel>;
	key: Scalars["String"];
};

export enum IndexedChannelsTypes {
	Own = "OWN",
	Collaboration = "COLLABORATION",
}

/** Autogenerated input type of InitiateChannelTransferMutation */
export type InitiateChannelTransferMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	owner_id?: InputMaybe<Scalars["ID"]>;
	owner_type?: InputMaybe<ChannelOwnerTypeEnum>;
	user_id?: InputMaybe<Scalars["ID"]>;
};

/** Autogenerated return type of InitiateChannelTransferMutation. */
export type InitiateChannelTransferMutationPayload = {
	__typename?: "InitiateChannelTransferMutationPayload";
	channel_transfer_request: ChannelTransferRequest;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of InviteCollaboratorMutation */
export type InviteCollaboratorMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	channel_id: Scalars["ID"];
	email: Scalars["String"];
};

/** Autogenerated return type of InviteCollaboratorMutation. */
export type InviteCollaboratorMutationPayload = {
	__typename?: "InviteCollaboratorMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of InviteGroupUsersMutation */
export type InviteGroupUsersMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	emails: Array<Scalars["String"]>;
};

/** Autogenerated return type of InviteGroupUsersMutation. */
export type InviteGroupUsersMutationPayload = {
	__typename?: "InviteGroupUsersMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	group: Group;
};

/** Autogenerated input type of InviteUsersMutation */
export type InviteUsersMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	emails: Array<Scalars["String"]>;
};

/** Autogenerated return type of InviteUsersMutation. */
export type InviteUsersMutationPayload = {
	__typename?: "InviteUsersMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	users: Array<User>;
};

/** An invited user */
export type Invitee = Model &
	UserInterface & {
		__typename?: "Invitee";
		avatar?: Maybe<Scalars["String"]>;
		badge?: Maybe<Scalars["String"]>;
		bio?: Maybe<Scalars["String"]>;
		can?: Maybe<UserCan>;
		channels?: Maybe<Array<Channel>>;
		/** Special channel field that eager loads all the owner and does not do pagination */
		channels_index?: Maybe<Array<IndexedChannels>>;
		/** @deprecated Use `channels` and `kontents` fields instead. */
		contents?: Maybe<Array<Connectable>>;
		created_at: Scalars["String"];
		custom_badge?: Maybe<Scalars["String"]>;
		email?: Maybe<Scalars["String"]>;
		first_name: Scalars["String"];
		following?: Maybe<Array<FollowableType>>;
		groups?: Maybe<Array<Group>>;
		has_had_recent_birthday?: Maybe<Scalars["Boolean"]>;
		hidden_email: Scalars["String"];
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		initials: Scalars["String"];
		is_approaching_connections_limit?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Use is_approaching_connections_limit */
		is_approaching_either_connections_limit: Scalars["Boolean"];
		is_canceled: Scalars["Boolean"];
		is_exceeding_connections_limit?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Use is_exceeding_connections_limit */
		is_exceeding_either_connections_limit: Scalars["Boolean"];
		is_indexable: Scalars["Boolean"];
		is_investor: Scalars["Boolean"];
		is_lifetime_premium: Scalars["Boolean"];
		is_me: Scalars["Boolean"];
		is_premium: Scalars["Boolean"];
		is_supporter: Scalars["Boolean"];
		is_upgradeable: Scalars["Boolean"];
		kontents?: Maybe<Array<Konnectable>>;
		last_name: Scalars["String"];
		name: Scalars["String"];
		slug?: Maybe<Scalars["String"]>;
		updated_at: Scalars["String"];
	};

/** An invited user */
export type InviteeAvatarArgs = {
	size?: InputMaybe<AvatarVersion>;
};

/** An invited user */
export type InviteeBioArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** An invited user */
export type InviteeChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** An invited user */
export type InviteeChannels_IndexArgs = {
	type?: InputMaybe<IndexedChannelsTypes>;
};

/** An invited user */
export type InviteeContentsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q?: InputMaybe<Scalars["String"]>;
	type?: InputMaybe<ConnectableTypeEnum>;
	include_group_channels?: InputMaybe<Scalars["Boolean"]>;
};

/** An invited user */
export type InviteeCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** An invited user */
export type InviteeCustom_BadgeArgs = {
	size?: InputMaybe<CustomBadgeVersion>;
};

/** An invited user */
export type InviteeFirst_NameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** An invited user */
export type InviteeFollowingArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	type?: InputMaybe<FollowingTypeEnum>;
};

/** An invited user */
export type InviteeGroupsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** An invited user */
export type InviteeHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** An invited user */
export type InviteeKontentsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q?: InputMaybe<Scalars["String"]>;
	type?: InputMaybe<ConnectableTypeEnum>;
	include_group_channels?: InputMaybe<Scalars["Boolean"]>;
};

/** An invited user */
export type InviteeLast_NameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** An invited user */
export type InviteeNameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** An invited user */
export type InviteeUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type Invoice = {
	__typename?: "Invoice";
	/** Dicsount applied to invoice */
	discount?: Maybe<Discount>;
	/** Can be `null` in cases where there is a manually sent invoice */
	next_payment_attempt_at?: Maybe<Scalars["String"]>;
	/** USD cents */
	subtotal?: Maybe<Scalars["Int"]>;
	/** USD cents */
	tax?: Maybe<Scalars["Int"]>;
	tax_rate?: Maybe<TaxRate>;
	/** USD cents */
	total?: Maybe<Scalars["Int"]>;
};

export type InvoiceNext_Payment_Attempt_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type Konnectable =
	| Attachment
	| Channel
	| Embed
	| Image
	| Link
	| PendingBlock
	| Text;

/** A link block */
export type Link = Block &
	ConnectableInterface &
	Model & {
		__typename?: "Link";
		can?: Maybe<BlockCan>;
		canonical_link?: Maybe<CanonicalLink>;
		channels?: Maybe<Array<Channel>>;
		channels_with_same_source?: Maybe<Array<Channel>>;
		/** @deprecated Channels do not have comments. Call this on Block. */
		comments?: Maybe<Array<Comment>>;
		/** Returns the outer channel if we are inside of one */
		connection?: Maybe<Connection>;
		connections?: Maybe<Array<Maybe<Connection>>>;
		content?: Maybe<Scalars["String"]>;
		counts?: Maybe<BlockCounts>;
		created_at: Scalars["String"];
		current_user_channels?: Maybe<Array<Channel>>;
		description?: Maybe<Scalars["String"]>;
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		image_updated_at?: Maybe<Scalars["String"]>;
		image_url?: Maybe<Scalars["String"]>;
		is_muted: Scalars["Boolean"];
		is_nsfw?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Avoid using if at all possible */
		kind?: Maybe<ConnectableKind>;
		klass?: Maybe<Scalars["String"]>;
		private_accessible_channels?: Maybe<Array<Channel>>;
		public_channels?: Maybe<Array<Channel>>;
		resized_image_url?: Maybe<Scalars["String"]>;
		source?: Maybe<ConnectableSource>;
		source_url?: Maybe<Scalars["String"]>;
		state: Scalars["String"];
		title: Scalars["String"];
		to_s: Scalars["String"];
		updated_at: Scalars["String"];
		user?: Maybe<User>;
		visibility?: Maybe<Scalars["String"]>;
	};

/** A link block */
export type LinkChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** A link block */
export type LinkChannels_With_Same_SourceArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A link block */
export type LinkCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** A link block */
export type LinkContentArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A link block */
export type LinkCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A link block */
export type LinkDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A link block */
export type LinkHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** A link block */
export type LinkImage_Updated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A link block */
export type LinkImage_UrlArgs = {
	size?: InputMaybe<ImageVersion>;
};

/** A link block */
export type LinkPrivate_Accessible_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A link block */
export type LinkPublic_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A link block */
export type LinkResized_Image_UrlArgs = {
	width?: InputMaybe<Scalars["Int"]>;
	height?: InputMaybe<Scalars["Int"]>;
	quality?: InputMaybe<Scalars["Int"]>;
	blur?: InputMaybe<Scalars["Int"]>;
	sharpen?: InputMaybe<Scalars["Int"]>;
	flatten?: InputMaybe<Scalars["Boolean"]>;
	fallback_format?: InputMaybe<ResizedImageFallbackFormat>;
	downloadable?: InputMaybe<Scalars["Boolean"]>;
};

/** A link block */
export type LinkTitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A link block */
export type LinkTo_SArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A link block */
export type LinkUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated input type of LoginMutation */
export type LoginMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	email: Scalars["String"];
	password: Scalars["String"];
};

/** Autogenerated return type of LoginMutation. */
export type LoginMutationPayload = {
	__typename?: "LoginMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** The current user */
export type Me = Model &
	UserInterface & {
		__typename?: "Me";
		authenticated_service?: Maybe<Authentication>;
		authentication_token?: Maybe<Scalars["String"]>;
		avatar?: Maybe<Scalars["String"]>;
		badge?: Maybe<Scalars["String"]>;
		banner?: Maybe<BannerEnum>;
		bio?: Maybe<Scalars["String"]>;
		can?: Maybe<UserCan>;
		channels?: Maybe<Array<Channel>>;
		/** Special channel field that eager loads all the owner and does not do pagination */
		channels_index?: Maybe<Array<IndexedChannels>>;
		connection_search?: Maybe<Array<Channel>>;
		/** @deprecated Use `channels` and `kontents` fields instead. */
		contents?: Maybe<Array<Connectable>>;
		counts?: Maybe<MeCounts>;
		created_at: Scalars["String"];
		custom_badge?: Maybe<Scalars["String"]>;
		customer?: Maybe<Customer>;
		email: Scalars["String"];
		feed?: Maybe<Feed>;
		first_name: Scalars["String"];
		flag: Scalars["Boolean"];
		flags?: Maybe<MeFlags>;
		following?: Maybe<Array<FollowableType>>;
		groups: Array<Group>;
		has_had_recent_birthday?: Maybe<Scalars["Boolean"]>;
		hidden_email: Scalars["String"];
		home_path?: Maybe<Scalars["String"]>;
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		initials: Scalars["String"];
		is_approaching_connections_limit?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Use is_approaching_connections_limit */
		is_approaching_either_connections_limit: Scalars["Boolean"];
		is_canceled: Scalars["Boolean"];
		is_confirmed: Scalars["Boolean"];
		is_exceeding_connections_limit: Scalars["Boolean"];
		/** @deprecated Use is_exceeding_connections_limit */
		is_exceeding_either_connections_limit: Scalars["Boolean"];
		/** @deprecated Use is_exceeding_connections_limit */
		is_exceeding_private_connections_limit: Scalars["Boolean"];
		is_indexable: Scalars["Boolean"];
		is_investor: Scalars["Boolean"];
		is_lifetime_premium: Scalars["Boolean"];
		is_me: Scalars["Boolean"];
		is_pending_confirmation: Scalars["Boolean"];
		is_pending_reconfirmation: Scalars["Boolean"];
		is_premium: Scalars["Boolean"];
		is_supporter: Scalars["Boolean"];
		is_upgradeable: Scalars["Boolean"];
		kontents?: Maybe<Array<Konnectable>>;
		last_name: Scalars["String"];
		name: Scalars["String"];
		non_premium_connections_limit?: Maybe<Scalars["Int"]>;
		/** @deprecated Use non_premium_connections_limit */
		non_premium_private_connections_limit?: Maybe<Scalars["Int"]>;
		notifications?: Maybe<Feed>;
		plan?: Maybe<Scalars["String"]>;
		plans?: Maybe<Array<Plan>>;
		/** Manifest for uploading new files to S3 */
		policy?: Maybe<Policy>;
		post_address?: Maybe<Scalars["String"]>;
		recent_connections?: Maybe<Array<Channel>>;
		settings?: Maybe<MeSettings>;
		slug?: Maybe<Scalars["String"]>;
		unconfirmed_email?: Maybe<Scalars["String"]>;
		updated_at: Scalars["String"];
	};

/** The current user */
export type MeAuthenticated_ServiceArgs = {
	provider?: InputMaybe<AuthenticatedServiceProvider>;
};

/** The current user */
export type MeAvatarArgs = {
	size?: InputMaybe<AvatarVersion>;
};

/** The current user */
export type MeBioArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** The current user */
export type MeChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** The current user */
export type MeChannels_IndexArgs = {
	type?: InputMaybe<IndexedChannelsTypes>;
};

/** The current user */
export type MeConnection_SearchArgs = {
	q?: InputMaybe<Scalars["String"]>;
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	include_open_channels?: InputMaybe<Scalars["Boolean"]>;
};

/** The current user */
export type MeContentsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q?: InputMaybe<Scalars["String"]>;
	type?: InputMaybe<ConnectableTypeEnum>;
	include_group_channels?: InputMaybe<Scalars["Boolean"]>;
};

/** The current user */
export type MeCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** The current user */
export type MeCustom_BadgeArgs = {
	size?: InputMaybe<CustomBadgeVersion>;
};

/** The current user */
export type MeFeedArgs = {
	type?: InputMaybe<Scalars["String"]>;
	offset?: InputMaybe<Scalars["Int"]>;
	limit?: InputMaybe<Scalars["Int"]>;
	start?: InputMaybe<Scalars["String"]>;
	end?: InputMaybe<Scalars["String"]>;
};

/** The current user */
export type MeFirst_NameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** The current user */
export type MeFlagArgs = {
	name: Scalars["String"];
};

/** The current user */
export type MeFollowingArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	type?: InputMaybe<FollowingTypeEnum>;
};

/** The current user */
export type MeGroupsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	type?: InputMaybe<GroupType>;
};

/** The current user */
export type MeHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** The current user */
export type MeKontentsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q?: InputMaybe<Scalars["String"]>;
	type?: InputMaybe<ConnectableTypeEnum>;
	include_group_channels?: InputMaybe<Scalars["Boolean"]>;
};

/** The current user */
export type MeLast_NameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** The current user */
export type MeNameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** The current user */
export type MeNotificationsArgs = {
	offset?: InputMaybe<Scalars["Int"]>;
	limit?: InputMaybe<Scalars["Int"]>;
	start?: InputMaybe<Scalars["String"]>;
	end?: InputMaybe<Scalars["String"]>;
};

/** The current user */
export type MeRecent_ConnectionsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
};

/** The current user */
export type MeUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type MeCounts = UserCountsInterface & {
	__typename?: "MeCounts";
	blocks?: Maybe<Scalars["Int"]>;
	channels?: Maybe<Scalars["Int"]>;
	connections?: Maybe<Scalars["Int"]>;
	connections_limit?: Maybe<Scalars["Int"]>;
	followers: Scalars["Int"];
	following: Scalars["Int"];
	following_channels: Scalars["Int"];
	following_groups: Scalars["Int"];
	following_users: Scalars["Int"];
	groups?: Maybe<Scalars["Int"]>;
	notifications?: Maybe<Scalars["Int"]>;
	/** @deprecated No longer applicable */
	private_connections?: Maybe<Scalars["Int"]>;
	/** @deprecated No longer applicable */
	private_connections_limit?: Maybe<Scalars["Int"]>;
};

export type MeFlagInput = {
	name: Scalars["String"];
	value: Scalars["Boolean"];
};

export type MeFlags = {
	__typename?: "MeFlags";
	has_seen_feed_connect_twitter?: Maybe<Scalars["Boolean"]>;
};

/** Flag keys */
export enum MeFlagsEnum {
	HasSeenFeedConnectTwitter = "HAS_SEEN_FEED_CONNECT_TWITTER",
}

export type MeSettings = {
	__typename?: "MeSettings";
	dark_mode: Scalars["Boolean"];
	exclude_from_indexes: Scalars["Boolean"];
	hide_notification_count: Scalars["Boolean"];
	include_open_channels_in_connection_search: Scalars["Boolean"];
	receive_editorial_emails: Scalars["Boolean"];
	receive_email: Scalars["String"];
	receive_group_premium_emails: Scalars["Boolean"];
	receive_newsletter: Scalars["Boolean"];
	receive_sunday_review_emails: Scalars["Boolean"];
	receive_tips_emails: Scalars["Boolean"];
	show_nsfw: Scalars["Boolean"];
	show_tour: Scalars["Boolean"];
};

/** Union of Channel members */
export type Member = Group | User;

/** Member types */
export enum MemberTypes {
	Group = "GROUP",
	User = "USER",
}

/** Fields common to all models */
export type Model = {
	created_at: Scalars["String"];
	id: Scalars["Int"];
	updated_at: Scalars["String"];
};

/** Fields common to all models */
export type ModelCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Fields common to all models */
export type ModelUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated input type of MoveConnectableMutation */
export type MoveConnectableMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	channel_id: Scalars["ID"];
	connectable: ConnectableInput;
	action?: InputMaybe<Movements>;
	insert_at?: InputMaybe<Scalars["Int"]>;
};

/** Autogenerated return type of MoveConnectableMutation. */
export type MoveConnectableMutationPayload = {
	__typename?: "MoveConnectableMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

export enum Movements {
	InsertAt = "INSERT_AT",
	MoveToTop = "MOVE_TO_TOP",
	MoveToBottom = "MOVE_TO_BOTTOM",
	MoveUp = "MOVE_UP",
	MoveDown = "MOVE_DOWN",
}

/** Fields common to models that can be muted */
export type Mutable = {
	is_muted: Scalars["Boolean"];
};

/** Mute-able object */
export type MutableType = Channel | Connectable | User;

/** Objects that can be muted */
export enum MutableTypeEnum {
	Block = "BLOCK",
	Channel = "CHANNEL",
	User = "USER",
}

export type Mutation = {
	__typename?: "Mutation";
	accept_channel_transfer?: Maybe<AcceptChannelTransferMutationPayload>;
	accept_group_invite?: Maybe<AcceptGroupInviteMutationPayload>;
	accept_invitation?: Maybe<AcceptInvitationMutationPayload>;
	add_channel_members?: Maybe<AddChannelMembersMutationPayload>;
	/** @deprecated Use `add_channel_member` instead */
	add_collaborators?: Maybe<AddCollaboratorMutationPayload>;
	add_credit_card?: Maybe<AddCreditCardMutationPayload>;
	add_group_users?: Maybe<AddGroupUsersMutationPayload>;
	add_payment_method?: Maybe<AddPaymentMethodMutationPayload>;
	apply_coupon_to_subscription?: Maybe<ApplyCouponToSubscriptionMutationPayload>;
	cancel_channel_transfer?: Maybe<CancelChannelTransferMutationPayload>;
	cancel_premium_subscription?: Maybe<CancelPremiumSubscriptionMutationPayload>;
	cancel_premium_subscriptions?: Maybe<CancelPremiumSubscriptionsMutationPayload>;
	clear_notifications?: Maybe<ClearNotificationsMutationPayload>;
	confirm_account?: Maybe<ConfirmAccountMutationPayload>;
	create_authenticated_service?: Maybe<CreateAuthenticatedServiceMutationPayload>;
	create_block?: Maybe<CreateBlockMutationPayload>;
	create_channel?: Maybe<CreateChannelPayload>;
	create_comment?: Maybe<CreateCommentMutationPayload>;
	create_connection?: Maybe<CreateConnectionMutationPayload>;
	create_group?: Maybe<CreateGroupMutationPayload>;
	create_group_invite?: Maybe<CreateGroupInviteMutationPayload>;
	create_portal_session?: Maybe<CreateCustomerPortalSessionMutationPayload>;
	create_user_message_channel?: Maybe<CreateUserMessageChannelMutationPayload>;
	delete_authenticated_service?: Maybe<DeleteAuthenticatedServiceMutationPayload>;
	delete_channel?: Maybe<DeleteChannelMutationPayload>;
	delete_comment?: Maybe<DeleteCommentMutationPayload>;
	delete_connection?: Maybe<DeleteConnectionMutationPayload>;
	delete_group?: Maybe<DeleteGroupMutationPayload>;
	delete_group_invite?: Maybe<DeleteGroupInviteMutationPayload>;
	dismiss_banner?: Maybe<DismissBannerMutationPayload>;
	downgrade_to_lifetime?: Maybe<DowngradeToLifetimeMutationPayload>;
	export_channel?: Maybe<ExportChannelMutationPayload>;
	flag_content?: Maybe<FlagContentMutationPayload>;
	follow?: Maybe<FollowMutationPayload>;
	initiate_channel_transfer?: Maybe<InitiateChannelTransferMutationPayload>;
	/** @deprecated Use `invite_channel_member` instead */
	invite_collaborator?: Maybe<InviteCollaboratorMutationPayload>;
	invite_group_users?: Maybe<InviteGroupUsersMutationPayload>;
	invite_users?: Maybe<InviteUsersMutationPayload>;
	login?: Maybe<LoginMutationPayload>;
	move_connectable_mutation?: Maybe<MoveConnectableMutationPayload>;
	mute?: Maybe<MuteMutationPayload>;
	/** @deprecated Use `mute` instead */
	mute_channel?: Maybe<MuteChannelMutationPayload>;
	read_notification?: Maybe<ReadNotificationMutationPayload>;
	regenerate_canonical_link?: Maybe<RegenerateCanonicalLinkMutationPayload>;
	registration?: Maybe<RegistrationMutationPayload>;
	reject_channel_transfer?: Maybe<RejectChannelTransferMutationPayload>;
	remove_channel_members?: Maybe<RemoveChannelMembersMutationPayload>;
	/** @deprecated Use `remove_channel_member` instead */
	remove_collaborators?: Maybe<RemoveCollaboratorsMutationPayload>;
	remove_connection?: Maybe<RemoveConnectionMutationPayload>;
	remove_credit_card?: Maybe<RemoveCreditCardMutationPayload>;
	remove_group_users?: Maybe<RemoveGroupUsersMutationPayload>;
	remove_payment_method?: Maybe<RemovePaymentMethodMutationPayload>;
	request_password_reset?: Maybe<RequestPasswordResetMutationPayload>;
	rerun_block_remote_processing?: Maybe<RerunBlockRemoteProcessingMutationPayload>;
	resend_confirmation_email?: Maybe<ResendConfirmationEmailMutationPayload>;
	resend_logged_out_confirmation_email?: Maybe<ResendLoggedOutConfirmationEmailMutationPayload>;
	reset_password?: Maybe<ResetPasswordMutationPayload>;
	restrict?: Maybe<RestrictMutationPayload>;
	set_me_flags?: Maybe<SetMeFlagsMutationPayload>;
	setup_incomplete_subscription?: Maybe<SetupIncompleteSubscriptionMutationPayload>;
	setup_incomplete_subscription_for_group?: Maybe<SetupIncompleteSubscriptionForGroupMutationPayload>;
	share_channel?: Maybe<ShareChannelMutationPayload>;
	subscribe_to_newsletter?: Maybe<SubscribeToNewsletterMutationPayload>;
	subscribe_to_premium?: Maybe<SubscribeToPremiumMutationPayload>;
	subscribe_to_premium_for_users?: Maybe<SubscribeToPremiumForUsersMutationPayload>;
	subscribe_to_premium_with_optional_token?: Maybe<SubscribeToPremiumWithOptionalTokenMutationPayload>;
	toggle_connection_selection?: Maybe<ToggleConnectionSelectionMutationPayload>;
	unfollow?: Maybe<UnfollowMutationPayload>;
	unmute?: Maybe<UnmuteMutationPayload>;
	/** @deprecated Use `unmute` instead */
	unmute_channel?: Maybe<UnmuteChannelMutationPayload>;
	update_account?: Maybe<UpdateAccountMutationPayload>;
	update_address?: Maybe<UpdateAddressMutationPayload>;
	update_block?: Maybe<UpdateBlockMutationPayload>;
	update_block_thumbnail?: Maybe<UpdateBlockThumbnailMutationPayload>;
	update_channel?: Maybe<UpdateChannelMutationPayload>;
	update_customer?: Maybe<UpdateCustomerMutationPayload>;
	/** @deprecated Use `set_me_flags` instead */
	update_flag?: Maybe<UpdateFlagMutationPayload>;
	update_group?: Maybe<UpdateGroupMutationPayload>;
	update_incomplete_subscription?: Maybe<UpdateIncompleteSubscriptionMutationPayload>;
	update_incomplete_subscription_for_group?: Maybe<UpdateIncompleteSubscriptionForGroupMutationPayload>;
};

export type MutationAccept_Channel_TransferArgs = {
	input: AcceptChannelTransferMutationInput;
};

export type MutationAccept_Group_InviteArgs = {
	input: AcceptGroupInviteMutationInput;
};

export type MutationAccept_InvitationArgs = {
	input: AcceptInvitationMutationInput;
};

export type MutationAdd_Channel_MembersArgs = {
	input: AddChannelMembersMutationInput;
};

export type MutationAdd_CollaboratorsArgs = {
	input: AddCollaboratorMutationInput;
};

export type MutationAdd_Credit_CardArgs = {
	input: AddCreditCardMutationInput;
};

export type MutationAdd_Group_UsersArgs = {
	input: AddGroupUsersMutationInput;
};

export type MutationAdd_Payment_MethodArgs = {
	input: AddPaymentMethodMutationInput;
};

export type MutationApply_Coupon_To_SubscriptionArgs = {
	input: ApplyCouponToSubscriptionMutationInput;
};

export type MutationCancel_Channel_TransferArgs = {
	input: CancelChannelTransferMutationInput;
};

export type MutationCancel_Premium_SubscriptionArgs = {
	input: CancelPremiumSubscriptionMutationInput;
};

export type MutationCancel_Premium_SubscriptionsArgs = {
	input: CancelPremiumSubscriptionsMutationInput;
};

export type MutationClear_NotificationsArgs = {
	input: ClearNotificationsMutationInput;
};

export type MutationConfirm_AccountArgs = {
	input: ConfirmAccountMutationInput;
};

export type MutationCreate_Authenticated_ServiceArgs = {
	input: CreateAuthenticatedServiceMutationInput;
};

export type MutationCreate_BlockArgs = {
	input: CreateBlockMutationInput;
};

export type MutationCreate_ChannelArgs = {
	input: CreateChannelInput;
};

export type MutationCreate_CommentArgs = {
	input: CreateCommentMutationInput;
};

export type MutationCreate_ConnectionArgs = {
	input: CreateConnectionMutationInput;
};

export type MutationCreate_GroupArgs = {
	input: CreateGroupMutationInput;
};

export type MutationCreate_Group_InviteArgs = {
	input: CreateGroupInviteMutationInput;
};

export type MutationCreate_Portal_SessionArgs = {
	input: CreateCustomerPortalSessionMutationInput;
};

export type MutationCreate_User_Message_ChannelArgs = {
	input: CreateUserMessageChannelMutationInput;
};

export type MutationDelete_Authenticated_ServiceArgs = {
	input: DeleteAuthenticatedServiceMutationInput;
};

export type MutationDelete_ChannelArgs = {
	input: DeleteChannelMutationInput;
};

export type MutationDelete_CommentArgs = {
	input: DeleteCommentMutationInput;
};

export type MutationDelete_ConnectionArgs = {
	input: DeleteConnectionMutationInput;
};

export type MutationDelete_GroupArgs = {
	input: DeleteGroupMutationInput;
};

export type MutationDelete_Group_InviteArgs = {
	input: DeleteGroupInviteMutationInput;
};

export type MutationDismiss_BannerArgs = {
	input: DismissBannerMutationInput;
};

export type MutationDowngrade_To_LifetimeArgs = {
	input: DowngradeToLifetimeMutationInput;
};

export type MutationExport_ChannelArgs = {
	input: ExportChannelMutationInput;
};

export type MutationFlag_ContentArgs = {
	input: FlagContentMutationInput;
};

export type MutationFollowArgs = {
	input: FollowMutationInput;
};

export type MutationInitiate_Channel_TransferArgs = {
	input: InitiateChannelTransferMutationInput;
};

export type MutationInvite_CollaboratorArgs = {
	input: InviteCollaboratorMutationInput;
};

export type MutationInvite_Group_UsersArgs = {
	input: InviteGroupUsersMutationInput;
};

export type MutationInvite_UsersArgs = {
	input: InviteUsersMutationInput;
};

export type MutationLoginArgs = {
	input: LoginMutationInput;
};

export type MutationMove_Connectable_MutationArgs = {
	input: MoveConnectableMutationInput;
};

export type MutationMuteArgs = {
	input: MuteMutationInput;
};

export type MutationMute_ChannelArgs = {
	input: MuteChannelMutationInput;
};

export type MutationRead_NotificationArgs = {
	input: ReadNotificationMutationInput;
};

export type MutationRegenerate_Canonical_LinkArgs = {
	input: RegenerateCanonicalLinkMutationInput;
};

export type MutationRegistrationArgs = {
	input: RegistrationMutationInput;
};

export type MutationReject_Channel_TransferArgs = {
	input: RejectChannelTransferMutationInput;
};

export type MutationRemove_Channel_MembersArgs = {
	input: RemoveChannelMembersMutationInput;
};

export type MutationRemove_CollaboratorsArgs = {
	input: RemoveCollaboratorsMutationInput;
};

export type MutationRemove_ConnectionArgs = {
	input: RemoveConnectionMutationInput;
};

export type MutationRemove_Credit_CardArgs = {
	input: RemoveCreditCardMutationInput;
};

export type MutationRemove_Group_UsersArgs = {
	input: RemoveGroupUsersMutationInput;
};

export type MutationRemove_Payment_MethodArgs = {
	input: RemovePaymentMethodMutationInput;
};

export type MutationRequest_Password_ResetArgs = {
	input: RequestPasswordResetMutationInput;
};

export type MutationRerun_Block_Remote_ProcessingArgs = {
	input: RerunBlockRemoteProcessingMutationInput;
};

export type MutationResend_Confirmation_EmailArgs = {
	input: ResendConfirmationEmailMutationInput;
};

export type MutationResend_Logged_Out_Confirmation_EmailArgs = {
	input: ResendLoggedOutConfirmationEmailMutationInput;
};

export type MutationReset_PasswordArgs = {
	input: ResetPasswordMutationInput;
};

export type MutationRestrictArgs = {
	input: RestrictMutationInput;
};

export type MutationSet_Me_FlagsArgs = {
	input: SetMeFlagsMutationInput;
};

export type MutationSetup_Incomplete_SubscriptionArgs = {
	input: SetupIncompleteSubscriptionMutationInput;
};

export type MutationSetup_Incomplete_Subscription_For_GroupArgs = {
	input: SetupIncompleteSubscriptionForGroupMutationInput;
};

export type MutationShare_ChannelArgs = {
	input: ShareChannelMutationInput;
};

export type MutationSubscribe_To_NewsletterArgs = {
	input: SubscribeToNewsletterMutationInput;
};

export type MutationSubscribe_To_PremiumArgs = {
	input: SubscribeToPremiumMutationInput;
};

export type MutationSubscribe_To_Premium_For_UsersArgs = {
	input: SubscribeToPremiumForUsersMutationInput;
};

export type MutationSubscribe_To_Premium_With_Optional_TokenArgs = {
	input: SubscribeToPremiumWithOptionalTokenMutationInput;
};

export type MutationToggle_Connection_SelectionArgs = {
	input: ToggleConnectionSelectionMutationInput;
};

export type MutationUnfollowArgs = {
	input: UnfollowMutationInput;
};

export type MutationUnmuteArgs = {
	input: UnmuteMutationInput;
};

export type MutationUnmute_ChannelArgs = {
	input: UnmuteChannelMutationInput;
};

export type MutationUpdate_AccountArgs = {
	input: UpdateAccountMutationInput;
};

export type MutationUpdate_AddressArgs = {
	input: UpdateAddressMutationInput;
};

export type MutationUpdate_BlockArgs = {
	input: UpdateBlockMutationInput;
};

export type MutationUpdate_Block_ThumbnailArgs = {
	input: UpdateBlockThumbnailMutationInput;
};

export type MutationUpdate_ChannelArgs = {
	input: UpdateChannelMutationInput;
};

export type MutationUpdate_CustomerArgs = {
	input: UpdateCustomerMutationInput;
};

export type MutationUpdate_FlagArgs = {
	input: UpdateFlagMutationInput;
};

export type MutationUpdate_GroupArgs = {
	input: UpdateGroupMutationInput;
};

export type MutationUpdate_Incomplete_SubscriptionArgs = {
	input: UpdateIncompleteSubscriptionMutationInput;
};

export type MutationUpdate_Incomplete_Subscription_For_GroupArgs = {
	input: UpdateIncompleteSubscriptionForGroupMutationInput;
};

/** Autogenerated input type of MuteChannelMutation */
export type MuteChannelMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of MuteChannelMutation. */
export type MuteChannelMutationPayload = {
	__typename?: "MuteChannelMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of MuteMutation */
export type MuteMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	type: MutableTypeEnum;
};

/** Autogenerated return type of MuteMutation. */
export type MuteMutationPayload = {
	__typename?: "MuteMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	mutable: MutableType;
};

/** Newsletters that can be subscribed to */
export enum NewsletterListEnum {
	/** General newsletter */
	General = "GENERAL",
	/** Editorial newsletter */
	Editorial = "EDITORIAL",
}

/** defines logical operation */
export enum OperationEnum {
	And = "AND",
	Or = "OR",
}

export type Order = {
	facet?: InputMaybe<SortOrderEnum>;
	dir?: InputMaybe<SortDirection>;
};

/** various services to find the original image */
export enum OriginalUrlServiceEnum {
	Bing = "BING",
	Google = "GOOGLE",
}

export type PaymentMethod = {
	__typename?: "PaymentMethod";
	card?: Maybe<CreditCard>;
	id?: Maybe<Scalars["String"]>;
	postal_code?: Maybe<Scalars["String"]>;
};

/** A block which has not yet found its calling */
export type PendingBlock = Block &
	ConnectableInterface &
	Model & {
		__typename?: "PendingBlock";
		can?: Maybe<BlockCan>;
		channels?: Maybe<Array<Channel>>;
		channels_with_same_source?: Maybe<Array<Channel>>;
		/** @deprecated Channels do not have comments. Call this on Block. */
		comments?: Maybe<Array<Comment>>;
		/** Returns the outer channel if we are inside of one */
		connection?: Maybe<Connection>;
		connections?: Maybe<Array<Maybe<Connection>>>;
		counts?: Maybe<BlockCounts>;
		created_at: Scalars["String"];
		current_user_channels?: Maybe<Array<Channel>>;
		description?: Maybe<Scalars["String"]>;
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		is_muted: Scalars["Boolean"];
		is_nsfw?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Avoid using if at all possible */
		kind?: Maybe<ConnectableKind>;
		klass?: Maybe<Scalars["String"]>;
		private_accessible_channels?: Maybe<Array<Channel>>;
		public_channels?: Maybe<Array<Channel>>;
		remote_source_url?: Maybe<Scalars["String"]>;
		source?: Maybe<ConnectableSource>;
		source_title?: Maybe<Scalars["String"]>;
		source_url?: Maybe<Scalars["String"]>;
		state: Scalars["String"];
		title: Scalars["String"];
		to_s: Scalars["String"];
		updated_at: Scalars["String"];
		user?: Maybe<User>;
		visibility?: Maybe<Scalars["String"]>;
	};

/** A block which has not yet found its calling */
export type PendingBlockChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** A block which has not yet found its calling */
export type PendingBlockChannels_With_Same_SourceArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A block which has not yet found its calling */
export type PendingBlockCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** A block which has not yet found its calling */
export type PendingBlockCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A block which has not yet found its calling */
export type PendingBlockDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A block which has not yet found its calling */
export type PendingBlockHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** A block which has not yet found its calling */
export type PendingBlockPrivate_Accessible_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A block which has not yet found its calling */
export type PendingBlockPublic_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A block which has not yet found its calling */
export type PendingBlockTitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A block which has not yet found its calling */
export type PendingBlockTo_SArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A block which has not yet found its calling */
export type PendingBlockUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type Plan = {
	__typename?: "Plan";
	/** USD cents */
	amount?: Maybe<Scalars["Float"]>;
	external_id?: Maybe<Scalars["String"]>;
	id: Scalars["ID"];
	is_hidden?: Maybe<Scalars["Boolean"]>;
	period_end_at?: Maybe<Scalars["String"]>;
	period_start_at?: Maybe<Scalars["String"]>;
	term?: Maybe<Scalars["String"]>;
};

export type PlanPeriod_End_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type PlanPeriod_Start_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A policy */
export type Policy = {
	__typename?: "Policy";
	AWSAccessKeyId: Scalars["String"];
	acl: Scalars["String"];
	bucket: Scalars["String"];
	expires: Scalars["String"];
	key?: Maybe<Scalars["String"]>;
	policy: Scalars["String"];
	signature: Scalars["String"];
	success_action_status: Scalars["String"];
};

export type PremiumSubscription = {
	__typename?: "PremiumSubscription";
	canceled_at?: Maybe<Scalars["String"]>;
	current_period_end_at?: Maybe<Scalars["String"]>;
	current_period_start_at?: Maybe<Scalars["String"]>;
	id: Scalars["ID"];
	is_canceled: Scalars["Boolean"];
	plan?: Maybe<Plan>;
	plan_id: Scalars["String"];
	users?: Maybe<Array<User>>;
};

export type PremiumSubscriptionCanceled_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type PremiumSubscriptionCurrent_Period_End_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type PremiumSubscriptionCurrent_Period_Start_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type PremiumSubscriptionUsersArgs = {
	status?: InputMaybe<CustomerStatuses>;
};

/** The query root for this schema */
export type Query = {
	__typename?: "Query";
	/** @deprecated Use `blokk` until this can be replaced with it */
	block?: Maybe<Connectable>;
	blokk?: Maybe<Konnectable>;
	/** A single channel */
	channel?: Maybe<Channel>;
	/** Multiple channels */
	channels?: Maybe<Array<Maybe<Channel>>>;
	connection?: Maybe<Connection>;
	coupon?: Maybe<Coupon>;
	explore?: Maybe<Array<SearchResult>>;
	exxplore?: Maybe<Array<Konnectable>>;
	/** Interface for getting the follow status of users or channels */
	followable?: Maybe<FollowableType>;
	group?: Maybe<Group>;
	group_by_code?: Maybe<GroupPreview>;
	identity?: Maybe<Identity>;
	/** Locates the invited user through their invitation token */
	invitee?: Maybe<Invitee>;
	/** The current logged in user */
	me?: Maybe<Me>;
	/** Interface for getting the mute status of blocks or channels */
	mutable?: Maybe<MutableType>;
	/** Locates the user through their reset password token */
	password_resettable_user?: Maybe<User>;
	password_token?: Maybe<User>;
	plans?: Maybe<Array<Plan>>;
	random_title?: Maybe<Scalars["String"]>;
	search?: Maybe<Array<SearchResult>>;
	searches?: Maybe<Searches>;
	/** An otherwise private channel that is accessible via the shared token */
	shared_channel?: Maybe<Channel>;
	ssearch?: Maybe<Array<SsearchResult>>;
	/** Is this endpoint operational? */
	status?: Maybe<Scalars["String"]>;
	/** A single user */
	user?: Maybe<User>;
};

/** The query root for this schema */
export type QueryBlockArgs = {
	id: Scalars["ID"];
};

/** The query root for this schema */
export type QueryBlokkArgs = {
	id: Scalars["ID"];
};

/** The query root for this schema */
export type QueryChannelArgs = {
	id: Scalars["ID"];
};

/** The query root for this schema */
export type QueryChannelsArgs = {
	ids: Array<InputMaybe<Scalars["ID"]>>;
};

/** The query root for this schema */
export type QueryConnectionArgs = {
	id: Scalars["ID"];
};

/** The query root for this schema */
export type QueryCouponArgs = {
	code: Scalars["String"];
};

/** The query root for this schema */
export type QueryExploreArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	type?: InputMaybe<SearchType>;
	block_filter?: InputMaybe<BlockFilterEnum>;
	timestamp?: InputMaybe<Scalars["DateTime"]>;
};

/** The query root for this schema */
export type QueryExxploreArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	type?: InputMaybe<SearchType>;
	block_filter?: InputMaybe<BlockFilterEnum>;
	timestamp?: InputMaybe<Scalars["DateTime"]>;
};

/** The query root for this schema */
export type QueryFollowableArgs = {
	id?: InputMaybe<Scalars["ID"]>;
	type?: InputMaybe<FollowableTypeEnum>;
};

/** The query root for this schema */
export type QueryGroupArgs = {
	id: Scalars["ID"];
};

/** The query root for this schema */
export type QueryGroup_By_CodeArgs = {
	code: Scalars["String"];
};

/** The query root for this schema */
export type QueryIdentityArgs = {
	id: Scalars["ID"];
};

/** The query root for this schema */
export type QueryInviteeArgs = {
	invitation_token: Scalars["String"];
};

/** The query root for this schema */
export type QueryMutableArgs = {
	id: Scalars["ID"];
	type: MutableTypeEnum;
};

/** The query root for this schema */
export type QueryPassword_Resettable_UserArgs = {
	reset_password_token: Scalars["String"];
};

/** The query root for this schema */
export type QueryPassword_TokenArgs = {
	token: Scalars["ID"];
};

/** The query root for this schema */
export type QuerySearchArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q: Scalars["String"];
	type?: InputMaybe<SearchType>;
};

/** The query root for this schema */
export type QueryShared_ChannelArgs = {
	token: Scalars["String"];
};

/** The query root for this schema */
export type QuerySsearchArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q: Scalars["String"];
	type?: InputMaybe<Array<InputMaybe<SsearchType>>>;
	block_filter?: InputMaybe<BlockFilterEnum>;
};

/** The query root for this schema */
export type QueryUserArgs = {
	id: Scalars["ID"];
};

/** Possible types for quick search results */
export type QuickSearchResult = Channel | Group | User;

/** Autogenerated input type of ReadNotificationMutation */
export type ReadNotificationMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	notification_id: Scalars["ID"];
};

/** Autogenerated return type of ReadNotificationMutation. */
export type ReadNotificationMutationPayload = {
	__typename?: "ReadNotificationMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	deed: Deed;
};

/** Autogenerated input type of RegenerateCanonicalLinkMutation */
export type RegenerateCanonicalLinkMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	block_id: Scalars["ID"];
};

/** Autogenerated return type of RegenerateCanonicalLinkMutation. */
export type RegenerateCanonicalLinkMutationPayload = {
	__typename?: "RegenerateCanonicalLinkMutationPayload";
	blokk: Konnectable;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of RegistrationMutation */
export type RegistrationMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	first_name: Scalars["String"];
	last_name: Scalars["String"];
	email: Scalars["String"];
	password: Scalars["String"];
	password_confirmation: Scalars["String"];
	receive_newsletter?: InputMaybe<Scalars["Boolean"]>;
	receive_tips_emails?: InputMaybe<Scalars["Boolean"]>;
	receive_editorial_emails?: InputMaybe<Scalars["Boolean"]>;
	validation_token?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of RegistrationMutation. */
export type RegistrationMutationPayload = {
	__typename?: "RegistrationMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** Autogenerated input type of RejectChannelTransferMutation */
export type RejectChannelTransferMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	token: Scalars["String"];
};

/** Autogenerated return type of RejectChannelTransferMutation. */
export type RejectChannelTransferMutationPayload = {
	__typename?: "RejectChannelTransferMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of RemoveChannelMembersMutation */
export type RemoveChannelMembersMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	members: Array<ChannelMemberInput>;
};

/** Autogenerated return type of RemoveChannelMembersMutation. */
export type RemoveChannelMembersMutationPayload = {
	__typename?: "RemoveChannelMembersMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of RemoveCollaboratorsMutation */
export type RemoveCollaboratorsMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	channel_id: Scalars["ID"];
	user_ids: Array<InputMaybe<Scalars["ID"]>>;
};

/** Autogenerated return type of RemoveCollaboratorsMutation. */
export type RemoveCollaboratorsMutationPayload = {
	__typename?: "RemoveCollaboratorsMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of RemoveConnectionMutation */
export type RemoveConnectionMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	connectable_id: Scalars["ID"];
	connectable_type: BaseConnectableTypeEnum;
	channel_id: Scalars["ID"];
};

/** Autogenerated return type of RemoveConnectionMutation. */
export type RemoveConnectionMutationPayload = {
	__typename?: "RemoveConnectionMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	status: Scalars["String"];
};

/** Autogenerated input type of RemoveCreditCardMutation */
export type RemoveCreditCardMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["String"];
};

/** Autogenerated return type of RemoveCreditCardMutation. */
export type RemoveCreditCardMutationPayload = {
	__typename?: "RemoveCreditCardMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	customer: Customer;
};

/** Autogenerated input type of RemoveGroupUsersMutation */
export type RemoveGroupUsersMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	user_ids: Array<InputMaybe<Scalars["ID"]>>;
};

/** Autogenerated return type of RemoveGroupUsersMutation. */
export type RemoveGroupUsersMutationPayload = {
	__typename?: "RemoveGroupUsersMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	group: Group;
};

/** Autogenerated input type of RemovePaymentMethodMutation */
export type RemovePaymentMethodMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["String"];
};

/** Autogenerated return type of RemovePaymentMethodMutation. */
export type RemovePaymentMethodMutationPayload = {
	__typename?: "RemovePaymentMethodMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	customer: Customer;
};

/** Autogenerated input type of RequestPasswordResetMutation */
export type RequestPasswordResetMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	email: Scalars["String"];
};

/** Autogenerated return type of RequestPasswordResetMutation. */
export type RequestPasswordResetMutationPayload = {
	__typename?: "RequestPasswordResetMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	email: Scalars["String"];
};

/** Autogenerated input type of RerunBlockRemoteProcessingMutation */
export type RerunBlockRemoteProcessingMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of RerunBlockRemoteProcessingMutation. */
export type RerunBlockRemoteProcessingMutationPayload = {
	__typename?: "RerunBlockRemoteProcessingMutationPayload";
	block: Connectable;
	blokk: Konnectable;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of ResendConfirmationEmailMutation */
export type ResendConfirmationEmailMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of ResendConfirmationEmailMutation. */
export type ResendConfirmationEmailMutationPayload = {
	__typename?: "ResendConfirmationEmailMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** Autogenerated input type of ResendLoggedOutConfirmationEmailMutation */
export type ResendLoggedOutConfirmationEmailMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	email?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of ResendLoggedOutConfirmationEmailMutation. */
export type ResendLoggedOutConfirmationEmailMutationPayload = {
	__typename?: "ResendLoggedOutConfirmationEmailMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	status: Scalars["String"];
};

/** Autogenerated input type of ResetPasswordMutation */
export type ResetPasswordMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	token: Scalars["String"];
	password: Scalars["String"];
	password_confirmation: Scalars["String"];
};

/** Autogenerated return type of ResetPasswordMutation. */
export type ResetPasswordMutationPayload = {
	__typename?: "ResetPasswordMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** Fallback format for resized images */
export enum ResizedImageFallbackFormat {
	Jpeg = "JPEG",
	Png = "PNG",
}

/** Autogenerated input type of RestrictMutation */
export type RestrictMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of RestrictMutation. */
export type RestrictMutationPayload = {
	__typename?: "RestrictMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	user: User;
};

/** Possible types for search results */
export type SearchResult = Channel | Connectable | Group | User;

/** Ways to sort blocks */
export enum SearchSorts {
	CreatedAt = "CREATED_AT",
	UpdatedAt = "UPDATED_AT",
	Random = "RANDOM",
	FollowerCount = "FOLLOWER_COUNT",
	Alpha = "ALPHA",
	Length = "LENGTH",
	Default = "DEFAULT",
}

/** Ways to filter search by type */
export enum SearchType {
	All = "ALL",
	User = "USER",
	Channel = "CHANNEL",
	Connectable = "CONNECTABLE",
}

export type Searches = {
	__typename?: "Searches";
	advanced: AdvancedResult;
	collaborators?: Maybe<Array<Member>>;
	quick?: Maybe<Array<QuickSearchResult>>;
};

export type SearchesAdvancedArgs = {
	term?: InputMaybe<Term>;
	where?: InputMaybe<Array<Where>>;
	what?: InputMaybe<What>;
	fields?: InputMaybe<Fields>;
	extensions?: InputMaybe<Array<ExtensionsEnum>>;
	order?: InputMaybe<Order>;
	period?: InputMaybe<Scalars["String"]>;
	after?: InputMaybe<Scalars["String"]>;
	before?: InputMaybe<Scalars["String"]>;
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	seed?: InputMaybe<Scalars["Int"]>;
};

export type SearchesCollaboratorsArgs = {
	query: Scalars["String"];
	types?: InputMaybe<Array<SearchesCollaboratorsType>>;
	limit?: InputMaybe<Scalars["Int"]>;
};

export type SearchesQuickArgs = {
	query: Scalars["String"];
	limit?: InputMaybe<Scalars["Int"]>;
	type?: InputMaybe<Array<InputMaybe<SsearchType>>>;
};

export enum SearchesCollaboratorsType {
	User = "USER",
	Group = "GROUP",
}

/** Autogenerated input type of SetMeFlagsMutation */
export type SetMeFlagsMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	flags?: InputMaybe<Array<InputMaybe<MeFlagInput>>>;
};

/** Autogenerated return type of SetMeFlagsMutation. */
export type SetMeFlagsMutationPayload = {
	__typename?: "SetMeFlagsMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** Autogenerated input type of SetupIncompleteSubscriptionForGroupMutation */
export type SetupIncompleteSubscriptionForGroupMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	/** ID of Group that users are a member of */
	group_id: Scalars["ID"];
	/** IDs of Users that this subscription should apply to */
	user_ids: Array<InputMaybe<Scalars["ID"]>>;
	plan_id: SupportedPlanEnum;
	coupon_code?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of SetupIncompleteSubscriptionForGroupMutation. */
export type SetupIncompleteSubscriptionForGroupMutationPayload = {
	__typename?: "SetupIncompleteSubscriptionForGroupMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	client_secret?: Maybe<Scalars["String"]>;
	subscription?: Maybe<StripeSubscription>;
};

/** Autogenerated input type of SetupIncompleteSubscriptionMutation */
export type SetupIncompleteSubscriptionMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	plan_id: SupportedPlanEnum;
	coupon_code?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of SetupIncompleteSubscriptionMutation. */
export type SetupIncompleteSubscriptionMutationPayload = {
	__typename?: "SetupIncompleteSubscriptionMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	client_secret?: Maybe<Scalars["String"]>;
	subscription?: Maybe<StripeSubscription>;
};

/** Autogenerated input type of ShareChannelMutation */
export type ShareChannelMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	enable: Scalars["Boolean"];
};

/** Autogenerated return type of ShareChannelMutation. */
export type ShareChannelMutationPayload = {
	__typename?: "ShareChannelMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** A spooky connectable */
export type SkeletalConnectable = {
	__typename?: "SkeletalConnectable";
	id: Scalars["Int"];
	type: Scalars["String"];
};

/** Directions to sort blocks */
export enum SortDirection {
	Asc = "ASC",
	Desc = "DESC",
}

/** Ways to sort Advanced Search results */
export enum SortOrderEnum {
	Score = "SCORE",
	Name = "NAME",
	CreatedAt = "CREATED_AT",
	UpdatedAt = "UPDATED_AT",
	Random = "RANDOM",
	ConnectionsCount = "CONNECTIONS_COUNT",
}

/** Ways to sort blocks */
export enum Sorts {
	Position = "POSITION",
	CreatedAt = "CREATED_AT",
	UpdatedAt = "UPDATED_AT",
}

/** Possible types for search results */
export type SsearchResult =
	| Attachment
	| Channel
	| Embed
	| Group
	| Image
	| Link
	| PendingBlock
	| Text
	| User;

/** Ways to filter search by type */
export enum SsearchType {
	User = "USER",
	Channel = "CHANNEL",
	Block = "BLOCK",
	Group = "GROUP",
}

export type StripeSubscription = {
	__typename?: "StripeSubscription";
	cancel_at_period_end: Scalars["Boolean"];
	canceled_at?: Maybe<Scalars["String"]>;
	current_period_end_at?: Maybe<Scalars["String"]>;
	current_period_start_at?: Maybe<Scalars["String"]>;
	customer: Customer;
	id: Scalars["ID"];
	invoice?: Maybe<Invoice>;
	status: Scalars["String"];
};

export type StripeSubscriptionCanceled_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type StripeSubscriptionCurrent_Period_End_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

export type StripeSubscriptionCurrent_Period_Start_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated input type of SubscribeToNewsletterMutation */
export type SubscribeToNewsletterMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	email: Scalars["String"];
	list?: InputMaybe<NewsletterListEnum>;
};

/** Autogenerated return type of SubscribeToNewsletterMutation. */
export type SubscribeToNewsletterMutationPayload = {
	__typename?: "SubscribeToNewsletterMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	status: Scalars["String"];
};

/** Autogenerated input type of SubscribeToPremiumForUsersMutation */
export type SubscribeToPremiumForUsersMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	/** ID of Group that users are a member of */
	group_id: Scalars["ID"];
	/** IDs of Users that this subscription should apply to */
	user_ids: Array<InputMaybe<Scalars["ID"]>>;
	/** Tokenized card/card ID from Stripe */
	token: Scalars["String"];
	plan_id: SupportedPlanEnum;
	coupon_code?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of SubscribeToPremiumForUsersMutation. */
export type SubscribeToPremiumForUsersMutationPayload = {
	__typename?: "SubscribeToPremiumForUsersMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	group: Group;
	me: Me;
	users: Array<User>;
};

/** Autogenerated input type of SubscribeToPremiumMutation */
export type SubscribeToPremiumMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	/** Tokenized card from Stripe */
	token: Scalars["String"];
	plan_id: SupportedPlanEnum;
	coupon_code?: InputMaybe<Scalars["String"]>;
	subscription_source?: InputMaybe<SubscriptionSourceEnum>;
};

/** Autogenerated return type of SubscribeToPremiumMutation. */
export type SubscribeToPremiumMutationPayload = {
	__typename?: "SubscribeToPremiumMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** Autogenerated input type of SubscribeToPremiumWithOptionalTokenMutation */
export type SubscribeToPremiumWithOptionalTokenMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	/** Tokenized card from Stripe */
	token?: InputMaybe<Scalars["String"]>;
	plan_id: SupportedPlanEnum;
	coupon_code?: InputMaybe<Scalars["String"]>;
	subscription_source?: InputMaybe<SubscriptionSourceEnum>;
};

/** Autogenerated return type of SubscribeToPremiumWithOptionalTokenMutation. */
export type SubscribeToPremiumWithOptionalTokenMutationPayload = {
	__typename?: "SubscribeToPremiumWithOptionalTokenMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** Possible places a person may upgrade to premium from */
export enum SubscriptionSourceEnum {
	Web = "WEB",
	Mobile = "MOBILE",
}

/** Subscription plans that are purchaseable by users */
export enum SupportedPlanEnum {
	Monthly = "MONTHLY",
	Yearly = "YEARLY",
	PlusYearly = "PLUS_YEARLY",
}

export type TaxRate = {
	__typename?: "TaxRate";
	country?: Maybe<Scalars["String"]>;
	description?: Maybe<Scalars["String"]>;
	display_name?: Maybe<Scalars["String"]>;
	id?: Maybe<Scalars["String"]>;
	jurisdiction?: Maybe<Scalars["String"]>;
	percentage?: Maybe<Scalars["Float"]>;
	state?: Maybe<Scalars["String"]>;
};

export type Term = {
	facet?: InputMaybe<Scalars["String"]>;
	op?: InputMaybe<OperationEnum>;
};

/** A text block */
export type Text = Block &
	ConnectableInterface &
	Model & {
		__typename?: "Text";
		can?: Maybe<BlockCan>;
		channels?: Maybe<Array<Channel>>;
		channels_with_same_source?: Maybe<Array<Channel>>;
		/** @deprecated Channels do not have comments. Call this on Block. */
		comments?: Maybe<Array<Comment>>;
		/** Returns the outer channel if we are inside of one */
		connection?: Maybe<Connection>;
		connections?: Maybe<Array<Maybe<Connection>>>;
		content: Scalars["String"];
		counts?: Maybe<BlockCounts>;
		created_at: Scalars["String"];
		current_user_channels?: Maybe<Array<Channel>>;
		description?: Maybe<Scalars["String"]>;
		/** URL to find the original image on various services */
		find_original_url?: Maybe<Scalars["String"]>;
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		is_muted: Scalars["Boolean"];
		is_nsfw?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Avoid using if at all possible */
		kind?: Maybe<ConnectableKind>;
		klass?: Maybe<Scalars["String"]>;
		private_accessible_channels?: Maybe<Array<Channel>>;
		public_channels?: Maybe<Array<Channel>>;
		source?: Maybe<ConnectableSource>;
		state: Scalars["String"];
		title: Scalars["String"];
		to_s: Scalars["String"];
		updated_at: Scalars["String"];
		user?: Maybe<User>;
		visibility?: Maybe<Scalars["String"]>;
	};

/** A text block */
export type TextChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** A text block */
export type TextChannels_With_Same_SourceArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A text block */
export type TextCommentsArgs = {
	direction?: InputMaybe<SortDirection>;
};

/** A text block */
export type TextContentArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A text block */
export type TextCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A text block */
export type TextDescriptionArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A text block */
export type TextFind_Original_UrlArgs = {
	service?: InputMaybe<OriginalUrlServiceEnum>;
};

/** A text block */
export type TextHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** A text block */
export type TextPrivate_Accessible_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A text block */
export type TextPublic_ChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	direction?: InputMaybe<SortDirection>;
};

/** A text block */
export type TextTitleArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A text block */
export type TextTo_SArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A text block */
export type TextUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated input type of ToggleConnectionSelectionMutation */
export type ToggleConnectionSelectionMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of ToggleConnectionSelectionMutation. */
export type ToggleConnectionSelectionMutationPayload = {
	__typename?: "ToggleConnectionSelectionMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	connection: Connection;
};

/** Autogenerated input type of UnfollowMutation */
export type UnfollowMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	type: FollowableTypeEnum;
};

/** Autogenerated return type of UnfollowMutation. */
export type UnfollowMutationPayload = {
	__typename?: "UnfollowMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	followable: FollowableType;
};

/** Autogenerated input type of UnmuteChannelMutation */
export type UnmuteChannelMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
};

/** Autogenerated return type of UnmuteChannelMutation. */
export type UnmuteChannelMutationPayload = {
	__typename?: "UnmuteChannelMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UnmuteMutation */
export type UnmuteMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	type: MutableTypeEnum;
};

/** Autogenerated return type of UnmuteMutation. */
export type UnmuteMutationPayload = {
	__typename?: "UnmuteMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	mutable: MutableType;
};

/** Autogenerated input type of UpdateAccountMutation */
export type UpdateAccountMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	email?: InputMaybe<Scalars["String"]>;
	first_name?: InputMaybe<Scalars["String"]>;
	last_name?: InputMaybe<Scalars["String"]>;
	home_path?: InputMaybe<Scalars["String"]>;
	receive_email?: InputMaybe<Scalars["String"]>;
	receive_newsletter?: InputMaybe<Scalars["Boolean"]>;
	receive_tips_emails?: InputMaybe<Scalars["Boolean"]>;
	receive_editorial_emails?: InputMaybe<Scalars["Boolean"]>;
	receive_group_premium_emails?: InputMaybe<Scalars["Boolean"]>;
	receive_sunday_review_emails?: InputMaybe<Scalars["Boolean"]>;
	hide_notification_count?: InputMaybe<Scalars["Boolean"]>;
	include_open_channels_in_connection_search?: InputMaybe<Scalars["Boolean"]>;
	dark_mode?: InputMaybe<Scalars["Boolean"]>;
	show_tour?: InputMaybe<Scalars["Boolean"]>;
	show_nsfw?: InputMaybe<Scalars["Boolean"]>;
	exclude_from_indexes?: InputMaybe<Scalars["Boolean"]>;
	bio?: InputMaybe<Scalars["String"]>;
	avatar_url?: InputMaybe<Scalars["String"]>;
	custom_badge_url?: InputMaybe<Scalars["String"]>;
	password?: InputMaybe<Scalars["String"]>;
	password_confirmation?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateAccountMutation. */
export type UpdateAccountMutationPayload = {
	__typename?: "UpdateAccountMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	me: Me;
};

/** Autogenerated input type of UpdateAddressMutation */
export type UpdateAddressMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	line1?: InputMaybe<Scalars["String"]>;
	line2?: InputMaybe<Scalars["String"]>;
	city?: InputMaybe<Scalars["String"]>;
	state?: InputMaybe<Scalars["String"]>;
	postal_code?: InputMaybe<Scalars["String"]>;
	country?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateAddressMutation. */
export type UpdateAddressMutationPayload = {
	__typename?: "UpdateAddressMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	customer?: Maybe<Customer>;
};

/** Autogenerated input type of UpdateBlockMutation */
export type UpdateBlockMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	title?: InputMaybe<Scalars["String"]>;
	description?: InputMaybe<Scalars["String"]>;
	content?: InputMaybe<Scalars["String"]>;
	alt_text?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateBlockMutation. */
export type UpdateBlockMutationPayload = {
	__typename?: "UpdateBlockMutationPayload";
	block: Connectable;
	blokk: Konnectable;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateBlockThumbnailMutation */
export type UpdateBlockThumbnailMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	image_url: Scalars["String"];
};

/** Autogenerated return type of UpdateBlockThumbnailMutation. */
export type UpdateBlockThumbnailMutationPayload = {
	__typename?: "UpdateBlockThumbnailMutationPayload";
	block: Connectable;
	blokk: Konnectable;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateChannelMutation */
export type UpdateChannelMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	title?: InputMaybe<Scalars["String"]>;
	visibility?: InputMaybe<ChannelVisibility>;
	description?: InputMaybe<Scalars["String"]>;
	content_flag?: InputMaybe<ContentFlag>;
	owner?: InputMaybe<ChannelMemberInput>;
};

/** Autogenerated return type of UpdateChannelMutation. */
export type UpdateChannelMutationPayload = {
	__typename?: "UpdateChannelMutationPayload";
	channel: Channel;
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
};

/** Autogenerated input type of UpdateCustomerMutation */
export type UpdateCustomerMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	default_credit_card_id?: InputMaybe<Scalars["String"]>;
	default_payment_method_id?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateCustomerMutation. */
export type UpdateCustomerMutationPayload = {
	__typename?: "UpdateCustomerMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	customer: Customer;
};

/** Autogenerated input type of UpdateFlagMutation */
export type UpdateFlagMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	name: MeFlagsEnum;
	value: Scalars["Boolean"];
};

/** Autogenerated return type of UpdateFlagMutation. */
export type UpdateFlagMutationPayload = {
	__typename?: "UpdateFlagMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	flags: MeFlags;
};

/** Autogenerated input type of UpdateGroupMutation */
export type UpdateGroupMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	id: Scalars["ID"];
	name?: InputMaybe<Scalars["String"]>;
	description?: InputMaybe<Scalars["String"]>;
	avatar_url?: InputMaybe<Scalars["String"]>;
};

/** Autogenerated return type of UpdateGroupMutation. */
export type UpdateGroupMutationPayload = {
	__typename?: "UpdateGroupMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	group: Group;
};

/** Autogenerated input type of UpdateIncompleteSubscriptionForGroupMutation */
export type UpdateIncompleteSubscriptionForGroupMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	plan_id?: InputMaybe<SupportedPlanEnum>;
	coupon_code?: InputMaybe<Scalars["String"]>;
	subscription_id: Scalars["String"];
	/** ID of Group that users are a member of */
	group_id: Scalars["ID"];
	/** IDs of Users that this subscription should apply to */
	user_ids: Array<InputMaybe<Scalars["ID"]>>;
};

/** Autogenerated return type of UpdateIncompleteSubscriptionForGroupMutation. */
export type UpdateIncompleteSubscriptionForGroupMutationPayload = {
	__typename?: "UpdateIncompleteSubscriptionForGroupMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	subscription?: Maybe<StripeSubscription>;
};

/** Autogenerated input type of UpdateIncompleteSubscriptionMutation */
export type UpdateIncompleteSubscriptionMutationInput = {
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: InputMaybe<Scalars["String"]>;
	plan_id?: InputMaybe<SupportedPlanEnum>;
	coupon_code?: InputMaybe<Scalars["String"]>;
	subscription_id: Scalars["String"];
};

/** Autogenerated return type of UpdateIncompleteSubscriptionMutation. */
export type UpdateIncompleteSubscriptionMutationPayload = {
	__typename?: "UpdateIncompleteSubscriptionMutationPayload";
	/** A unique identifier for the client performing the mutation. */
	clientMutationId?: Maybe<Scalars["String"]>;
	subscription?: Maybe<StripeSubscription>;
};

/** A single user */
export type User = Followable &
	Model &
	Mutable &
	UserInterface & {
		__typename?: "User";
		avatar?: Maybe<Scalars["String"]>;
		badge?: Maybe<Scalars["String"]>;
		bio?: Maybe<Scalars["String"]>;
		can?: Maybe<UserCan>;
		channels?: Maybe<Array<Channel>>;
		/** Special channel field that eager loads all the owner and does not do pagination */
		channels_index?: Maybe<Array<IndexedChannels>>;
		/** @deprecated Use `channels` and `kontents` fields instead. */
		contents?: Maybe<Array<Connectable>>;
		counts?: Maybe<UserCounts>;
		created_at: Scalars["String"];
		custom_badge?: Maybe<Scalars["String"]>;
		first_name: Scalars["String"];
		followers?: Maybe<Array<User>>;
		following?: Maybe<Array<FollowableType>>;
		groups?: Maybe<Array<Group>>;
		has_had_recent_birthday?: Maybe<Scalars["Boolean"]>;
		hidden_email: Scalars["String"];
		href?: Maybe<Scalars["String"]>;
		id: Scalars["Int"];
		initials: Scalars["String"];
		is_approaching_connections_limit?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Use is_approaching_connections_limit */
		is_approaching_either_connections_limit: Scalars["Boolean"];
		is_canceled: Scalars["Boolean"];
		is_exceeding_connections_limit?: Maybe<Scalars["Boolean"]>;
		/** @deprecated Use is_exceeding_connections_limit */
		is_exceeding_either_connections_limit: Scalars["Boolean"];
		is_followed: Scalars["Boolean"];
		is_indexable: Scalars["Boolean"];
		is_investor: Scalars["Boolean"];
		is_lifetime_premium: Scalars["Boolean"];
		is_me: Scalars["Boolean"];
		is_muted: Scalars["Boolean"];
		is_premium: Scalars["Boolean"];
		is_restricted: Scalars["Boolean"];
		is_supporter: Scalars["Boolean"];
		is_upgradeable: Scalars["Boolean"];
		kontents?: Maybe<Array<Konnectable>>;
		last_name: Scalars["String"];
		name: Scalars["String"];
		slug?: Maybe<Scalars["String"]>;
		updated_at: Scalars["String"];
	};

/** A single user */
export type UserAvatarArgs = {
	size?: InputMaybe<AvatarVersion>;
};

/** A single user */
export type UserBioArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** A single user */
export type UserChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** A single user */
export type UserChannels_IndexArgs = {
	type?: InputMaybe<IndexedChannelsTypes>;
};

/** A single user */
export type UserContentsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q?: InputMaybe<Scalars["String"]>;
	type?: InputMaybe<ConnectableTypeEnum>;
	include_group_channels?: InputMaybe<Scalars["Boolean"]>;
};

/** A single user */
export type UserCreated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** A single user */
export type UserCustom_BadgeArgs = {
	size?: InputMaybe<CustomBadgeVersion>;
};

/** A single user */
export type UserFirst_NameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A single user */
export type UserFollowersArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A single user */
export type UserFollowingArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	type?: InputMaybe<FollowingTypeEnum>;
};

/** A single user */
export type UserGroupsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** A single user */
export type UserHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** A single user */
export type UserKontentsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q?: InputMaybe<Scalars["String"]>;
	type?: InputMaybe<ConnectableTypeEnum>;
	include_group_channels?: InputMaybe<Scalars["Boolean"]>;
};

/** A single user */
export type UserLast_NameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A single user */
export type UserNameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** A single user */
export type UserUpdated_AtArgs = {
	relative?: InputMaybe<Scalars["Boolean"]>;
	format?: InputMaybe<Scalars["String"]>;
};

/** The actions that the CurrentUser can perform on the User */
export type UserCan = {
	__typename?: "UserCan";
	cancel_premium: Scalars["Boolean"];
	edit_profile_description: Scalars["Boolean"];
	follow: Scalars["Boolean"];
	manage: Scalars["Boolean"];
	message: Scalars["Boolean"];
	set_custom_badge: Scalars["Boolean"];
};

export type UserCounts = UserCountsInterface & {
	__typename?: "UserCounts";
	blocks?: Maybe<Scalars["Int"]>;
	channels?: Maybe<Scalars["Int"]>;
	connections?: Maybe<Scalars["Int"]>;
	followers: Scalars["Int"];
	following: Scalars["Int"];
	following_channels: Scalars["Int"];
	following_groups: Scalars["Int"];
	following_users: Scalars["Int"];
	groups?: Maybe<Scalars["Int"]>;
};

export type UserCountsInterface = {
	blocks?: Maybe<Scalars["Int"]>;
	channels?: Maybe<Scalars["Int"]>;
	connections?: Maybe<Scalars["Int"]>;
	followers: Scalars["Int"];
	following: Scalars["Int"];
	following_channels: Scalars["Int"];
	following_groups: Scalars["Int"];
	following_users: Scalars["Int"];
	groups?: Maybe<Scalars["Int"]>;
};

/** Fields common to all users */
export type UserInterface = {
	avatar?: Maybe<Scalars["String"]>;
	badge?: Maybe<Scalars["String"]>;
	bio?: Maybe<Scalars["String"]>;
	can?: Maybe<UserCan>;
	channels?: Maybe<Array<Channel>>;
	/** Special channel field that eager loads all the owner and does not do pagination */
	channels_index?: Maybe<Array<IndexedChannels>>;
	/** @deprecated Use `channels` and `kontents` fields instead. */
	contents?: Maybe<Array<Connectable>>;
	custom_badge?: Maybe<Scalars["String"]>;
	first_name: Scalars["String"];
	following?: Maybe<Array<FollowableType>>;
	groups?: Maybe<Array<Group>>;
	has_had_recent_birthday?: Maybe<Scalars["Boolean"]>;
	hidden_email: Scalars["String"];
	href?: Maybe<Scalars["String"]>;
	initials: Scalars["String"];
	is_approaching_connections_limit?: Maybe<Scalars["Boolean"]>;
	/** @deprecated Use is_approaching_connections_limit */
	is_approaching_either_connections_limit: Scalars["Boolean"];
	is_canceled: Scalars["Boolean"];
	is_exceeding_connections_limit?: Maybe<Scalars["Boolean"]>;
	/** @deprecated Use is_exceeding_connections_limit */
	is_exceeding_either_connections_limit: Scalars["Boolean"];
	is_indexable: Scalars["Boolean"];
	is_investor: Scalars["Boolean"];
	is_lifetime_premium: Scalars["Boolean"];
	is_me: Scalars["Boolean"];
	is_premium: Scalars["Boolean"];
	is_supporter: Scalars["Boolean"];
	is_upgradeable: Scalars["Boolean"];
	kontents?: Maybe<Array<Konnectable>>;
	last_name: Scalars["String"];
	name: Scalars["String"];
	slug?: Maybe<Scalars["String"]>;
};

/** Fields common to all users */
export type UserInterfaceAvatarArgs = {
	size?: InputMaybe<AvatarVersion>;
};

/** Fields common to all users */
export type UserInterfaceBioArgs = {
	format?: InputMaybe<Format>;
	no_links?: InputMaybe<Scalars["Boolean"]>;
};

/** Fields common to all users */
export type UserInterfaceChannelsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<ChannelsSort>;
	direction?: InputMaybe<SortDirection>;
};

/** Fields common to all users */
export type UserInterfaceChannels_IndexArgs = {
	type?: InputMaybe<IndexedChannelsTypes>;
};

/** Fields common to all users */
export type UserInterfaceContentsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q?: InputMaybe<Scalars["String"]>;
	type?: InputMaybe<ConnectableTypeEnum>;
	include_group_channels?: InputMaybe<Scalars["Boolean"]>;
};

/** Fields common to all users */
export type UserInterfaceCustom_BadgeArgs = {
	size?: InputMaybe<CustomBadgeVersion>;
};

/** Fields common to all users */
export type UserInterfaceFirst_NameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** Fields common to all users */
export type UserInterfaceFollowingArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	type?: InputMaybe<FollowingTypeEnum>;
};

/** Fields common to all users */
export type UserInterfaceGroupsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
};

/** Fields common to all users */
export type UserInterfaceHrefArgs = {
	absolute?: InputMaybe<Scalars["Boolean"]>;
};

/** Fields common to all users */
export type UserInterfaceKontentsArgs = {
	per?: InputMaybe<Scalars["Int"]>;
	page?: InputMaybe<Scalars["Int"]>;
	sort_by?: InputMaybe<SearchSorts>;
	direction?: InputMaybe<SortDirection>;
	seed?: InputMaybe<Scalars["Int"]>;
	q?: InputMaybe<Scalars["String"]>;
	type?: InputMaybe<ConnectableTypeEnum>;
	include_group_channels?: InputMaybe<Scalars["Boolean"]>;
};

/** Fields common to all users */
export type UserInterfaceLast_NameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

/** Fields common to all users */
export type UserInterfaceNameArgs = {
	truncate?: InputMaybe<Scalars["Int"]>;
};

export type What = {
	facets?: InputMaybe<Array<WhatEnum>>;
	op?: InputMaybe<OperationEnum>;
};

/** defines for what searched */
export enum WhatEnum {
	All = "ALL",
	Block = "BLOCK",
	Channel = "CHANNEL",
	Group = "GROUP",
	User = "USER",
	Attachment = "ATTACHMENT",
	Image = "IMAGE",
	Link = "LINK",
	Media = "MEDIA",
	Text = "TEXT",
}

export type Where = {
	facet?: InputMaybe<WhereEnum>;
	id?: InputMaybe<Scalars["ID"]>;
};

/** defines search space */
export enum WhereEnum {
	All = "ALL",
	My = "MY",
	Following = "FOLLOWING",
	User = "USER",
	Group = "GROUP",
	Channel = "CHANNEL",
}
